# `ForkJoin`

此框架一般有两个工具是我们经常使用的，一个是有返回值的`RecursiveTask`，另一个是无返回值的`RecursiveAction`。下面看一个累加的基本例子

```java
package concurrent.phase3;

import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.RecursiveTask;
import java.util.stream.IntStream;

public class Demo15 {

    private final static int MAX_THRESHOLD = 3;

    private static class CalculatedRecursiveTask extends RecursiveTask<Integer> {

        private final int start;

        private final int end;

        public CalculatedRecursiveTask(int start, int end) {
            this.start = start;
            this.end = end;
        }

        @Override
        protected Integer compute() {
            if (end - start <= MAX_THRESHOLD) {
                return IntStream.rangeClosed(start, end).sum();
            } else {
                int middle = start + (end - start) / 2;
                CalculatedRecursiveTask left = new CalculatedRecursiveTask(start, middle);
                CalculatedRecursiveTask right = new CalculatedRecursiveTask(middle + 1, end);
                left.fork();
                right.fork();
                return left.join() + right.join();
            }
        }
    }

    public static void main(String[] args) {
        final ForkJoinPool forkJoinPool = new ForkJoinPool();
        ForkJoinTask<Integer> future = forkJoinPool.submit(new CalculatedRecursiveTask(1, 10));
        try {
            Integer result = future.get();
            System.out.println(result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
package concurrent.phase3;

import java.util.Optional;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.IntStream;

public class Demo16 {

    private final static int MAX_THRESHOLD = 3;

    private final static AtomicInteger SUM = new AtomicInteger(0);

    public static void main(String[] args) {
        final ForkJoinPool pool = new ForkJoinPool();
        pool.submit(new CalculatedRecursiveAction(0, 10));
        try {
            pool.awaitTermination(10, TimeUnit.SECONDS);
            Optional.of(SUM).ifPresent(System.out::println);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static class CalculatedRecursiveAction extends RecursiveAction {

        private final int start;

        private final int end;

        public CalculatedRecursiveAction(int start, int end) {
            this.start = start;
            this.end = end;
        }

        @Override
        protected void compute() {
            if (end - start <= MAX_THRESHOLD) {
                SUM.addAndGet(IntStream.rangeClosed(start, end).sum());
            } else {
                int middle = start + (end - start) / 2;
                CalculatedRecursiveAction left = new CalculatedRecursiveAction(start, middle);
                CalculatedRecursiveAction right = new CalculatedRecursiveAction(middle + 1, end);
                left.fork();
                right.fork();
                left.join();
                right.join();
            }
        }
    }
}
```

参考：`https://cloud.tencent.com/developer/article/1625131`

整体思路就是分治累加+任务窃取。

`Fork/Join` 使用两个类来完成以上两件事情：

* `ForkJoinTask`：我们要使用 `ForkJoin` 框架，必须首先创建一个` ForkJoin` 任务。它提供在任务中执行 `fork()` 和 `join()` 操作的机制，通常情况下我们不需要直接继承 `ForkJoinTask` 类，而只需要继承它的子类，`Fork/Join` 框架提供了以下两个子类：
    * `RecursiveAction`：用于没有返回结果的任务。
    * `RecursiveTask` ：用于有返回结果的任务。
* `ForkJoinPool` ：`ForkJoinTask` 需要通过 `ForkJoinPool` 来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。



## 构造函数

```java
public ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, boolean asyncMode)
```

* `parallelism`：可并行级别，`Fork/Join`框架将依据这个并行级别的设定，决定框架内并行执行的线程数量。并行的每一个任务都会有一个线程进行处理，但是千万不要将这个属性理解成`Fork/Join`框架中最多存在的线程数量，也不要将这个属性和`ThreadPoolExecutor`线程池中的`corePoolSize、maximumPoolSize`属性进行比较，因为`ForkJoinPool`的组织结构和工作方式与后者完全不一样。而后续的讨论中，读者还可以发现`Fork/Join`框架中可存在的线程数量和这个参数值的关系并不是绝对的关联（有依据但并不全由它决定）。

* `factory`：当`Fork/Join`框架创建一个新的线程时，同样会用到线程创建工厂。只不过这个线程工厂不再需要实现`ThreadFactory`接口，而是需要实现`ForkJoinWorkerThreadFactory`接口。后者是一个函数式接口，只需要实现一个名叫`newThread`的方法。在`Fork/Join`框架中有一个默认的`ForkJoinWorkerThreadFactory`接口实现：`DefaultForkJoinWorkerThreadFactory`。

* `handler`：异常捕获处理器。当执行的任务中出现异常，并从任务中被抛出时，就会被`handler`捕获。

* `asyncMode`：这个参数也非常重要，从字面意思来看是指的异步模式，它并不是说`Fork/Join`框架是采用同步模式还是采用异步模式工作。`Fork/Join`框架中为每一个独立工作的线程准备了对应的待执行任务队列，这个任务队列是使用数组进行组合的双向队列。即是说存在于队列中的待执行任务，即可以使用先进先出的工作模式，也可以使用后进先出的工作模式。当`asyncMode`设置为`ture`的时候，队列采用先进先出方式工作；反之则是采用后进先出的方式工作，该值默认为`false`。如果你对`Fork/Join`框架没有特定的执行要求，可以直接使用不带有任何参数的构造函数。也就是说推荐基于当前操作系统可以使用的`CPU`内核数作为`Fork/Join`框架内最大并行任务数量，这样可以保证`CPU`在处理并行任务时，尽量少发生任务线程间的运行状态切换



实例化`ForkJoinPool`一般不推荐使用`new`，而是使用

```java
ForkJoinPool commonPool =  ForkJoinPool.commonPool();
```

这个静态方法所获得的`ForkJoinPools`实例是由整个应用进程共享的，并且它适合绝大多数的应用系统场景。使用`commonPool`通常可以帮助应用程序中多种需要进行归并计算的任务共享计算资源，从而使后者发挥最大作用（`ForkJoinPools`中的工作线程在闲置时会被缓慢回收，并在随后需要使用时被恢复），而这种获取`ForkJoinPools`实例的方式，才是`Doug Lea`推荐的使用方式。



## `ForkJoinPool` 提交任务的方式对比

| 方法名                    | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `invoke(ForkJoinTask t)`  | 提交任务并一直阻塞直到任务执行完成返回合并结果。             |
| `execute(ForkJoinTask t)` | 异步执行任务，无返回值。                                     |
| `submit(ForkJoinTask t)`  | 异步执行任务，返回`task`本身，可以通过`task.get()`方法获取合并之后的结果 |

```java
// 这是一个同步方法，有返回值
public <T> T invoke(ForkJoinTask<T> task) {
    if (task == null)
        throw new NullPointerException();
    externalPush(task);
    return task.join();
}
// 这里异步执行，无返回值
public void execute(ForkJoinTask<?> task) {
    if (task == null)
        throw new NullPointerException();
    externalPush(task);
}
// 异步有返回值
public <T> ForkJoinTask<T> submit(ForkJoinTask<T> task) {
    if (task == null)
        throw new NullPointerException();
    externalPush(task);
    return task;
}
```



## 工作线程和工作队列

`ForkJoinPool`中的工作线程采用的是`ForkJoinWorkerThread`。它继承了`Thread`类。内部有两个非常关键的变量如下：

```java
final ForkJoinPool pool;                // the pool this thread works in
final ForkJoinPool.WorkQueue workQueue; // work-stealing mechanics
```

`pool`表示这个工作线程所属的`ForkJoinPool`实例；

`workQueue`表示与这个工作线程对应的待执行子任务队列。 `WorkQueue`是`ForkJoinPool`的一个内部类，它并没有像`Java`中的其他队列那样，继承`BlockingQueue`提供`offer/poll`等方法来入队和出队。而是基于双端链表单独实现的，提供了`push()/pop()`方法来操作，队列中的元素其实就是被分割的子任务。它支持任务窃取，这一切的操作也必须要求是线程安全的，因此内部也大量的应用到了`UnSafe`基础类来保障线程安全。

队列在执行的过程中，如果发生阻塞，可以将其暂时放在一边，然后去执行其依赖的其他子任务，按照队列中的处理顺序就是每次都处理**最后添加到队列中的任务（LIFO）**。而如果其他队列中的人物已被执行完，那么就会进行任务窃取，然后执行，窃取时遵循（FIFO），也就是窃取最老的任务。







# `Phaser`

此工具和之前的`CountDownLatch, CyclicBarrier`比较类似，但是功能相比起来要强一些。

```java
// 对比CountDownLatch
package concurrent.phase3;

import java.util.Random;
import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

public class Demo17 {

    private static final Random random = new Random(System.currentTimeMillis());

    static class Task extends Thread{
        private final Phaser phaser;

        public Task(Phaser phaser) {
            this.phaser = phaser;
            //task进来之后先要注册，而不是一开始就固定好有几个线程
            this.phaser.register();
            start();
        }

        @Override
        public void run() {
            System.out.println("The worker [" + getName() + "] is working...");
            try {
                TimeUnit.SECONDS.sleep(random.nextInt(5));
                // 这里相当于CountDownLatch的await方法
                this.phaser.arriveAndAwaitAdvance();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        Phaser phaser = new Phaser();
        IntStream.rangeClosed(1, 5).boxed().map(e -> phaser).forEach(Task::new);
        // 这里将main线程也注册进来，相比起来这里可以动态的添加，
        // 而CountDownLatch和CyclicBarrier则需要一开始就确定
        // 同时还可以使用bulkRegister批量注册
        phaser.register();
        phaser.arriveAndAwaitAdvance();
        System.out.println("task done");
    }
}
```



```java
// 对比CyclicBarrier
package concurrent.phase3;

import java.util.Random;
import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;

/**
 * 这里模拟CyclicBarrier的使用，其中计数器可以重复使用。
 * 比如这里有假设有多个线程先需要所有人参加完长跑，然后再进行自行车比赛，然后再进行跳高。
 * 这就好比三个比赛阶段
 */
public class Demo18 {

    private static final Random random = new Random(System.currentTimeMillis());

    static class Athlete extends Thread{

        private final int no;
        private final Phaser phaser;

        public Athlete(int no, Phaser phaser) {
            this.no = no;
            this.phaser = phaser;
        }

        @Override
        public void run() {
            try {
                doPhaseWork(": start running.", ": end running.");
                doPhaseWork(": start bicycle.", ": end bicycle.");
                doPhaseWork(": start jump.", ": end jump.");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        private void doPhaseWork(String s, String s2) throws InterruptedException {
            System.out.println(no + s);
            TimeUnit.SECONDS.sleep(random.nextInt(5));
            System.out.println(no + s2);
            phaser.arriveAndAwaitAdvance();
        }
    }

    public static void main(String[] args) {
        // 一次性注册5个线程，不需要使用register方法注册
        Phaser phaser = new Phaser(5);
        for (int i = 0; i < 5; i++) {
            new Athlete(i, phaser).start();
        }
    }
}
```

这里可以看到计数器是可以重复使用的。但是如果说其中有一个人中途受伤了，无法参加跳高了

```java
package concurrent.phase3;

import java.util.Random;
import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;

/**
 * 这里模拟CyclicBarrier的使用，其中计数器可以重复使用。
 * 比如这里有假设有多个线程先需要所有人参加完长跑，然后再进行自行车比赛，然后再进行跳高。
 * 这就好比三个比赛阶段，但是这里可能和之前不一样，有一个人可能受伤了，无法参加最后的跳高
 */
public class Demo19 {

    private static final Random random = new Random(System.currentTimeMillis());

    static class AthleteInjured extends Thread{

        private final int no;
        private final Phaser phaser;

        public AthleteInjured(int no, Phaser phaser) {
            this.no = no;
            this.phaser = phaser;
        }

        @Override
        public void run() {
            try {
                doPhaseWork(": start running.", ": end running.");
                doPhaseWork(": start bicycle.", ": end bicycle.");
                System.out.println("I'm injured");
                //退出，解除注册
                this.phaser.arriveAndDeregister();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        private void doPhaseWork(String s, String s2) throws InterruptedException {
            System.out.println(no + s);
            TimeUnit.SECONDS.sleep(random.nextInt(5));
            System.out.println(no + s2);
            phaser.arriveAndAwaitAdvance();
        }
    }

    static class Athlete extends Thread{

        private final int no;
        private final Phaser phaser;

        public Athlete(int no, Phaser phaser) {
            this.no = no;
            this.phaser = phaser;
        }

        @Override
        public void run() {
            try {
                doPhaseWork(": start running.", ": end running.");
                doPhaseWork(": start bicycle.", ": end bicycle.");
                doPhaseWork(": start jump.", ": end jump.");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        private void doPhaseWork(String s, String s2) throws InterruptedException {
            System.out.println(no + s);
            TimeUnit.SECONDS.sleep(random.nextInt(5));
            System.out.println(no + s2);
            phaser.arriveAndAwaitAdvance();
        }
    }

    public static void main(String[] args) {
        // 一次性注册5个线程
        Phaser phaser = new Phaser(5);
        for (int i = 0; i < 4; i++) {
            new Athlete(i, phaser).start();
        }
        new AthleteInjured(4, phaser).start();
    }
}
```

那还有这样一种场景，就是将一个几个线程去执行某个任务，而这个任务可以分为几个阶段，对于主线程来说，我只是关系这些线程的第一个阶段的完成情况，对于其他阶段的完成并不关心

```java
package concurrent.phase3;

import java.util.Random;
import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;

public class Demo20 {

    private static final Random random = new Random(System.currentTimeMillis());

    static class Athlete extends Thread{

        private final int no;
        private final Phaser phaser;

        public Athlete(int no, Phaser phaser) {
            this.no = no;
            this.phaser = phaser;
        }

        @Override
        public void run() {
            try {
                System.out.println(no + ": start first work");
                TimeUnit.SECONDS.sleep(random.nextInt(5));
                System.out.println(no + ": end first work");
                // 此方法并不会阻塞，同时也不会对计数器进行变更
                phaser.arrive();

                System.out.println(no + ": start second work");
                TimeUnit.SECONDS.sleep(random.nextInt(5));
                System.out.println(no + ": end second work");

                phaser.arriveAndAwaitAdvance();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        // 一次性注册4个线程
        Phaser phaser = new Phaser(5);
        for (int i = 0; i < 4; i++) {
            new Athlete(i, phaser).start();
        }
        phaser.arriveAndAwaitAdvance();
        System.out.println("the first phase work done");
    }
}
```





# `ExecutorService`

先看下基本创建方式

```java
package concurrent.phase3;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.ThreadPoolExecutor.AbortPolicy;
import java.util.concurrent.TimeUnit;

public class Demo21 {

    public static void main(String[] args) {
        ThreadPoolExecutor pool = test1();
        int activeAccount = -1;
        int queueSize = -1;
        while (true) {
            if (activeAccount != pool.getActiveCount() || queueSize != pool.getQueue().size()) {
                System.out.println("活跃线程数: " + pool.getActiveCount());
                System.out.println("核心线程数: " + pool.getCorePoolSize());
                System.out.println("队列线程数: " + pool.getQueue().size());
                System.out.println("最大线程数: " + pool.getMaximumPoolSize());
                activeAccount = pool.getActiveCount();
                queueSize = pool.getQueue().size();
                System.out.println("-------------------");
            }
        }
    }

    public static ThreadPoolExecutor test1() {
        ThreadPoolExecutor pool = new ThreadPoolExecutor(1, 2, 30, TimeUnit.SECONDS,
            new ArrayBlockingQueue<Runnable>(1),
            r -> {
                Thread t = new Thread(r);
                return t;
            }, new AbortPolicy());
        System.out.println("the thread pool created done");
        // 通过提交不同数量线程来检测
        pool.execute(() -> sleepSeconds(100));
        pool.execute(() -> sleepSeconds(10));
        pool.execute(() -> sleepSeconds(100));
        return pool;
    }

    private static void sleepSeconds(long sec) {
        try {
            System.out.println("* " + Thread.currentThread().getName() + " *");
            TimeUnit.SECONDS.sleep(sec);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```



```java
package concurrent.phase3;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.ThreadPoolExecutor.AbortPolicy;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

public class Demo22 {

    public static void main(String[] args) {
        ThreadPoolExecutor pool = new ThreadPoolExecutor(10, 20, 30, TimeUnit.SECONDS,
            new ArrayBlockingQueue<Runnable>(10),
            r -> {
                Thread t = new Thread(r);
                return t;
            }, new AbortPolicy());

        IntStream.range(0, 20).boxed().forEach(i -> pool.execute(() -> {
            try {
                TimeUnit.SECONDS.sleep(10);
                System.out.println("* " + Thread.currentThread().getName() + " ->" + i + " done");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }));
        // 表示将线程池停止，但是是非阻塞的，需要当前工作的所有线程执行完，而队列中的线程不会提交，直接退出，无返回值
        // 而shutdownNow则会将正在工作都线程处理完，同样不会再执行queue中的线程，而是将队列中的线程返回出去，也是非阻塞的
        pool.shutdown();

        // 如果想在这里阻塞住
        try {
            // 设置一个最大等待时间，若线程都执行完了则不会继续等待
            pool.awaitTermination(1, TimeUnit.HOURS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

这里要注意`shutDown`和`shutDownNow`的区别：

当前提交20个线程，10个在工作中，10个在队列中，若此时调用`shutDown`，则会发生首先等待10个正在工作的线程执行完，然后将所有20个线程全部打断退出。此时若调用`shutDownNow`则首先会尝试打断正在工作的10个线程，然后打断退出，并将队列中的10个线程返回出去。

有时候可能在线程执行的时候卡住了导致无法停止线程池，此时可以在创建线程的工厂方法中设置线程为守护线程，这样是一种避免卡死的方式。



## 几种线程池

```java
package concurrent.phase3;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Demo23 {

    public static void main(String[] args) throws InterruptedException {
        test4();
    }

    public static void test4() throws InterruptedException {
        // return new ForkJoinPool(Runtime.getRuntime().availableProcessors(),
        //             ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);
        // ExecutorService newWorkStealingPool(int parallelism)
        // ExecutorService newWorkStealingPool()
        ExecutorService pool = Executors.newWorkStealingPool();
        List<Callable<String>> callableList = IntStream.range(0, 20).boxed().map(i -> (Callable<String>) () -> {
            System.out.println("Thread: " + Thread.currentThread().getName());
            TimeUnit.SECONDS.sleep(100);
            return "task->" + i;
        }).collect(Collectors.toList());

        // 利用 Java 8 的流来处理 invokeAll 调用返回的所有 Future
        // 批量提交可调用的另一种方法是 invokeAny()，它与 invokeAll() 略有不同。 该方法不会返回所有的 Future 对象，它只返回第一个执行完毕任务的结果。
        pool.invokeAll(callableList).stream().map(future -> {
            try {
                return future.get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }).forEach(System.out::println);

        pool.shutdown();
    }

    public static void test3() {
        // return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,
        //                                    new LinkedBlockingQueue<Runnable>()));
        // 其实这里和 Executors.newFixedThreadPool(1); 差不多，这里主要是为了隐藏一些API，如getActiveCount
        
        // ScheduledExecutorService newSingleThreadScheduledExecutor()
        // ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)
        ExecutorService pool = Executors.newSingleThreadExecutor();
    }

    public static void test2() throws InterruptedException {
        // return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
        // 这里就不会自动销毁了，同时核心线程数量和最大线程数量相等，最大活跃线程数量就为10
        // ExecutorService newFixedThreadPool(int nThreads)
        // ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)
        ExecutorService pool = Executors.newFixedThreadPool(10);
        System.out.println(((ThreadPoolExecutor) pool).getActiveCount());
        pool.execute(() -> System.out.println("========="));
        System.out.println(((ThreadPoolExecutor) pool).getActiveCount());
        IntStream.range(0, 20).boxed().forEach(i -> pool.execute(() -> {
            try {
                TimeUnit.SECONDS.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("* " + Thread.currentThread().getName() + " ->" + i + " done");
        }));
        TimeUnit.SECONDS.sleep(1);
        System.out.println(((ThreadPoolExecutor) pool).getActiveCount());
        pool.shutdown();
    }

    public static void test1() throws InterruptedException {
        // return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
        // 这里队列只能放一个线程，此时就会一直创建，直到最大线程，60s后会将所有线程回收释放掉，线程池自动销毁了
        // ExecutorService newCachedThreadPool()
        // ExecutorService newCachedThreadPool(ThreadFactory threadFactory)
        ExecutorService pool = Executors.newCachedThreadPool();
        System.out.println(((ThreadPoolExecutor) pool).getActiveCount());
        pool.execute(() -> System.out.println("========="));
        System.out.println(((ThreadPoolExecutor) pool).getActiveCount());

        IntStream.range(0, 100).boxed().forEach(i -> pool.execute(() -> {
            try {
                TimeUnit.SECONDS.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("* " + Thread.currentThread().getName() + " ->" + i + " done");
        }));
        TimeUnit.SECONDS.sleep(1);
        System.out.println(((ThreadPoolExecutor) pool).getActiveCount());
    }
}
```



```java
package concurrent.phase3;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

public class Demo24 {

    public static void main(String[] args) throws InterruptedException {
        test1();
    }

    public static void test1() throws InterruptedException {
        // return new ScheduledThreadPoolExecutor(corePoolSize);
        
        // ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
        // ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);

        Runnable task = () -> System.out.println("Scheduling: " + System.nanoTime());
        // 延迟3s执行
        ScheduledFuture<?> future = executor.schedule(task, 3, TimeUnit.SECONDS);

        TimeUnit.MILLISECONDS.sleep(1337);

        long remainingDelay = future.getDelay(TimeUnit.MILLISECONDS);
        System.out.printf("Remaining Delay: %sms", remainingDelay);

    }
}
```

这是一个简单的实现了定时功能的线程池，如上可以延迟3秒执行，还有另外的方法可以实现循环执行，但有不同

```java
// 下次执行时间 = 上次执行时间 + 延迟时间
public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);
// 下次执行时间 = 上次执行完时间 + 延迟时间
public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);
```



## 相关 `API` 使用

```java
package concurrent.phase3;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.atomic.AtomicInteger;

public class Demo25 {

    public static void main(String[] args) {
        test2();
    }

    private void test1() {
        ExecutorService pool = Executors.newFixedThreadPool(1);
        pool.execute(() -> {
            System.out.println("执行相关线程任务");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        pool.shutdown();

        // 调用shutdown后肯定状态时关闭的，但是并不代表一定就终止了
        System.out.println("线程池是否关闭: " + pool.isShutdown());
        System.out.println("线程池是否暂停: " + pool.isTerminated());
        System.out.println("线程池是否停止过程中: " + ((ThreadPoolExecutor) pool).isTerminating());
        // 不能再执行
//        pool.execute(() -> System.out.println("是否还可以执行?"));
    }

    private static void test2() {
        // 传入自己的工厂方法来捕获异常
        ExecutorService pool = Executors.newFixedThreadPool(1, new MyThreadFactory());
        pool.execute(() -> {
            System.out.println("执行相关线程任务");
            try {
                Thread.sleep(1000);
                int i = 1 / 0;
                System.out.println(i);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        pool.shutdown();
    }


    private static class MyThreadFactory implements ThreadFactory {

        private static final AtomicInteger SEQ = new AtomicInteger();

        @Override
        public Thread newThread(Runnable r) {
            Thread thread = new Thread(r);
            thread.setName("ThreadName:" + SEQ.getAndIncrement());
            // 这里通过实现一个handle方法来捕获异常
            thread.setUncaughtExceptionHandler((t, cause) -> {
                System.out.println("the thread" + thread.getName() + " execute failed");
                cause.printStackTrace();
            });
            return thread;
        }
    }
}
```



线程池在执行时还可以设置前置和后置操作

```java
package concurrent.phase3;

import java.util.Objects;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.ThreadPoolExecutor.AbortPolicy;
import java.util.concurrent.TimeUnit;

public class Demo26 {

    public static void main(String[] args) {

        MyPool pool = new MyPool(1, 2, 30, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(1),
            Thread::new, new AbortPolicy());

        pool.execute(new MyRunnable(1) {
            @Override
            public void run() {
                System.out.println("-----1----");
            }
        });
        pool.execute(new MyRunnable(2) {
            @Override
            public void run() {
                System.out.println("-----2----");
            }
        });
        pool.shutdown();
    }

    private abstract static class MyRunnable implements Runnable {

        private final int no;

        public MyRunnable(int no) {
            this.no = no;
        }

        protected int getData() {
            return this.no;
        }
    }

    private static class MyPool extends ThreadPoolExecutor {

        public MyPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,
            BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory,
            RejectedExecutionHandler handler) {
            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
        }

        @Override
        protected void beforeExecute(Thread t, Runnable r) {
            System.out.println("init the " + ((MyRunnable) r).getData());
        }

        @Override
        protected void afterExecute(Runnable r, Throwable t) {
            if (Objects.isNull(t)) {
                // 这里就表明线程还是存在的
                System.out.println("success");
            } else {
                System.out.println("failed");
            }
        }
    }
}
```



```java
package concurrent.phase3;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Demo27 {

    public static void main(String[] args) throws Exception {
//        testInvokeAny();
        testTimeout();
    }

    private static void testInvokeAny() throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(10);
        List<Callable<Integer>> callableList = IntStream.range(0, 5).boxed().map(i -> (Callable<Integer>) () -> {
            TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(20));
            System.out.println(Thread.currentThread().getName() + " --> " + i);
            return i;
        }).collect(Collectors.toList());

        // 这是一个同步方法，这里任意执行一个线程
        Integer val = pool.invokeAny(callableList);
        System.out.println("finished, value: " + val);
        //其他线程是否还会执行呢？
        // 从打印结果中可以发现其他线程不会再执行，已经被取消了
        pool.shutdown();
    }

    private static void testTimeout() throws InterruptedException, ExecutionException, TimeoutException {
        ExecutorService pool = Executors.newFixedThreadPool(10);
        // 这是一个同步方法，这里任意执行一个线程
        // 这里测试下超时
        Integer val = pool.invokeAny(
            IntStream.range(0, 5).boxed().map(i -> (Callable<Integer>) () -> {
                TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(20));
                System.out.println(Thread.currentThread().getName() + " --> " + i);
                return i;
            }).collect(Collectors.toList()), 3, TimeUnit.SECONDS
        );
        System.out.println("finished, value: " + val);
        pool.shutdown();
    }

    private static void testInvokeAll() throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(10);
        List<Callable<Integer>> callableList = IntStream.range(0, 5).boxed().map(i -> (Callable<Integer>) () -> {
            TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(20));
            System.out.println(Thread.currentThread().getName() + " --> " + i);
            return i;
        }).collect(Collectors.toList());

        // 这里可以看到执行所有，但是有一个问题是这里虽然使用了并行流，但是仍然要分成三个阶段，这个问题在jdk9中已解决
        pool.invokeAll(callableList).parallelStream().map(future -> {
            try {
                return future.get();
            } catch (Exception e) {
                e.printStackTrace();
            }
            return null;
        }).forEach(System.out::println);
        
        // 这里我们可以获取队列，然后单独往其中添加线程，也可以执行
        BlockingQueue<Runnable> queue = ((ThreadPoolExecutor) pool).getQueue();
        queue.add(() -> System.out.println("this is a runnable thread"));
        pool.shutdown();
    }
}
```

最后要注意，线程池的执行方法`execute, submit, invoke`三个点区别。`execute`和`submit`都是异步的，前面一个没有返回值，后面一个有返回值，而`invoke`是同步的，有返回值。



## 内置拒绝策略

* `ThreadPoolExecutor.AbortPolicy`: 默认策略，丢弃任务并抛出`RejectedExecutionException`异常。 
* `ThreadPoolExecutor.DiscardPolicy`：丢弃任务，但是不抛出异常。 
* `ThreadPoolExecutor.DiscardOldestPolicy`：丢弃队列最前面的任务，然后重新提交被拒绝的任务 
* `ThreadPoolExecutor.CallerRunsPolicy`：由调用线程（提交任务的线程）处理该任务





## 内置的队列

`BlockingQueue`是双缓冲队列。`BlockingQueue`内部使用两条队列，允许两个线程同时向队列一个存储，一个取出操作。在保证并发安全的同时，提高了队列的存取效率。

常用的几种`BlockingQueue`：

* `ArrayBlockingQueue(int i)`:规定大小的`BlockingQueue`，其构造必须指定大小。其所含的对象是`FIFO`顺序排序的。

* `LinkedBlockingQueue()或者(int i)`:大小不固定的`BlockingQueue`，若其构造时指定大小，生成的`BlockingQueue`有大小限制，不指定大小，其大小有`Integer.MAX_VALUE`来决定。其所含的对象是`FIFO`顺序排序的。`fixedThreadPool`使用此队列，在使用此线程池的时候一定要指定大小。`singleThreadExecutor`也使用此队列。

* `PriorityBlockingQueue()或者(int i)`:类似于`LinkedBlockingQueue`，但是其所含对象的排序不是`FIFO`，而是依据对象的自然顺序或者构造函数的`Comparator`决定。

* `SynchronizedQueue()`:特殊的`BlockingQueue`，对其的操作必须是放和取交替完成。`cachedThreadPool`使用此队列，此队列只能存放一个线程





# `Future, Callable`

先看基本方法的使用

```java
package concurrent.phase3;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class Demo28 {

    public static void main(String[] args) throws Exception {
//        testGet();
//        testTimeout();
//        testDone();
        testCancel();
    }

    private static void testGet() throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newCachedThreadPool();
        Future<Integer> future = pool.submit(() -> {
            try {
                TimeUnit.SECONDS.sleep(10);
                System.out.println("被中断后不会执行");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 10;
        });

        // future 抛出了InterruptedException， 这里是main线程打断了，但是要注意，线程池还没有停止
        Thread.currentThread().interrupt();
        Integer res = future.get();
        System.out.println("结果： " + res);
        pool.shutdown();
    }

    private static void testTimeout() throws ExecutionException, InterruptedException, TimeoutException {
        ExecutorService pool = Executors.newCachedThreadPool();
        Future<Integer> future = pool.submit(() -> {
            try {
                TimeUnit.SECONDS.sleep(10);
                // 超时当前线程还是会执行，只是调用者不会执行了
                System.out.println("超时后还是会执行");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 10;
        });

        // 这里设置超时时间，超时后线程池是没有停止的
        Integer res = future.get(5, TimeUnit.SECONDS);
        System.out.println("结果： " + res);
        pool.shutdown();
    }

    private static void testDone() throws Exception {
        ExecutorService pool = Executors.newCachedThreadPool();
        Future<Integer> future = pool.submit(() -> {
            try {
                TimeUnit.SECONDS.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 10;
        });
        System.out.println(future.get());
        // Completion may be due to normal termination, an exception, or cancellation
        System.out.println(future.isDone());
        pool.shutdown();
    }

    private static void testCancel() throws Exception {
        ExecutorService pool = Executors.newCachedThreadPool();
        Future<Integer> future = pool.submit(() -> {
            try {
                TimeUnit.SECONDS.sleep(5);
                System.out.println("cancel后还是会执行");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            while (!Thread.interrupted()) {

            }
            return 10;
        });
        // 传入true会中断线程停止任务，传入false则会让线程正常执行至完成
        // 传入false参数只能取消还没有开始的任务，若任务已经开始了，就任由其运行下去。
        boolean canceled = future.cancel(false);
        System.out.println("取消成功：" + canceled);
        System.out.println("1. 是否被取消了：" + future.isCancelled());
        System.out.println("2. 是否完成了：" + future.isDone());
    }
}
```

当创建了`Future`实例，任务可能有以下三种状态：

* 等待状态。此时调用`cancel()`方法不管传入`true`还是`false`都会标记为取消，任务依然保存在任务队列中，但当轮到此任务运行时会直接跳过。

* 完成状态。此时`cancel()`不会起任何作用，因为任务已经完成了。

* 运行中。此时传入`true`会中断正在执行的任务，传入`false`则不会中断。

`Future.cancel(true)`适用于： 

1. 长时间处于运行的任务，并且能够处理`interruption`

`Future.cancel(false)`适用于： 

1. 未能处理`interruption`的任务 
2. 不清楚任务是否支持取消 
3. 需要等待已经开始的任务执行完成

这里可以看到`cancel`方法也并不是任何情况下都可以成功将线程打断，最终的办法还是使用自定义工厂来将线程设置为守护线程来达到一定会终止的目的。**同时要注意调用此方法后是不能再获取到结果的**



# `CompletionService`

上面的`Futrue`可以发现有些不足，比如无法回调，我们需要阻塞去获取最后的结果，同时如果是一组任务，那需要在所有任务都执行完了再做其他的事情。

```java
package concurrent.phase3;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class Demo29 {

    public static void main(String[] args) throws Exception {
        test1();
    }

    private static void test1() throws Exception {

        ExecutorService pool = Executors.newFixedThreadPool(2);
        List<Callable<Integer>> callableList = Arrays.asList(
            () -> {
            TimeUnit.SECONDS.sleep(10);
            System.out.println("the first finished");
            return 1;
        },
            () -> {
            TimeUnit.SECONDS.sleep(20);
            System.out.println("the second finished");
            return 2;
        });

        ExecutorCompletionService<Integer> completionService = new ExecutorCompletionService<>(pool);
        List<Future<Integer>> futures = new ArrayList<>();
        callableList.forEach(e -> futures.add(completionService.submit(e)));
//        Future<Integer> future;
//        // take方法会阻塞住
//        while ((future = completionService.take()) != null) {
//            System.out.println(future.get());
//        }

        // 这里future可能为空，当然可以设置等待时间
        Future<Integer> future = completionService.poll(11, TimeUnit.SECONDS);
        System.out.println(future.get());
    }
}
```

这里在一组任务处理的过程中，如果有率先完成的，那么可以先处理，无需等待其他线程任务。





# `CompletableFuture`

使用`Future`获得异步执行结果时，要么调用阻塞方法`get()`，要么轮询看`isDone()`是否为`true`，这两种方法都不是很好，因为主线程也会被迫等待。

```java
package concurrent.phase3;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class Demo30 {

    public static void main(String[] args) throws Exception {
//        test();
//        test1();
//        test2();
//        test3();

        // 将BiFunction同时作用于两个阶段的结果
        // 下面这里的s1就是前面执行的结果，而s2就是输出"java"的CompletableFuture的结果
        CompletableFuture.supplyAsync(() -> "Hello ")
            .thenApply(s -> s + "world ")
            .thenApply(String::toUpperCase)
            .thenCombine(CompletableFuture.completedFuture("java "), (s1, s2) -> s1 + s2)
            .thenAccept(System.out::println);

        System.out.println("----------");

        // BiConsumer支持同时对两个Stage的结果进行操作
        String original = "Message ";
        StringBuilder result = new StringBuilder();
        CompletableFuture.completedFuture(original).thenApply(String::toUpperCase)
            .thenAcceptBoth(
                CompletableFuture.completedFuture(original).thenApply(String::toLowerCase),
                (s1, s2) -> result.append(s1).append(s2));
        System.out.println(result);
    }

    private static void test() throws Exception {
        ExecutorService pool = Executors.newFixedThreadPool(2);
        // runAsync不关心前面的结果
        CompletableFuture.runAsync(() -> {
            try {
                System.out.println("execute");
                TimeUnit.SECONDS.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, pool).whenComplete((v, t) -> System.out.println("done"));

        // CompletableFuture中有默认的线程池，而其中的线程都是守护线程，如果没有休眠，那么main线程执行完后线程池中的所有线程都会关闭
        // 当然如果我们想使用自己的线程池也可以，只需要将自定义线程池作为runAsync的第二个参数即可
        TimeUnit.SECONDS.sleep(30);
    }

    /**
     * 这里可以分别设置任务执行成功或者失败时的回调处理任务，无需等待
     */
    private static void test1() throws Exception {
        // 这里任务是一个Supplier对象
        CompletableFuture<Double> future = CompletableFuture.supplyAsync(Demo30::fetchPrice);
        //执行成功，回调任务是一个Consumer对象，对应的还有thenRunAsync
        future.thenAccept(result -> System.out.println("success, result: " + result));
        // 执行失败，回调任务是一个Function对象
        future.exceptionally(e -> {
            System.out.println("failed");
            e.printStackTrace();
            return null;
        });
        // 这里要注意：如果不休眠，可能任务还未执行完主线程就关闭了，此时CompletableFuture默认使用的线程池会立刻关闭
        TimeUnit.SECONDS.sleep(10);
    }

    /**
     * 多个Completable串行执行, 第一个CompletableFuture根据证券名称查询证券代码，第二个CompletableFuture根据证券代码查询证券价格
     */
    private static void test2() throws Exception {
        // 第一个任务:Supplier对象
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> queryCode("中国石油"));

        // future1成功后继续执行下一个任务:Function对象
        CompletableFuture<Double> future2 = future1.thenApplyAsync(Demo30::fetchPrice);

        // 执行成功后打印结果
        future2.thenAccept(result -> System.out.println("result: " + result));

        TimeUnit.SECONDS.sleep(10);
    }

    /**
     * 同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作
     */
    private static void test3() throws Exception {
        // 第一阶段
        CompletableFuture<String> future1FromSina = CompletableFuture.supplyAsync(
            () -> queryCode("中国石油", "https://finance.sina.com.cn/code/"));
        CompletableFuture<String> future1From163 = CompletableFuture.supplyAsync(
            () -> queryCode("中国石油", "https://money.163.com/code/"));

        // 用anyOf合并为一个新的CompletableFuture:
        // 当然对应的还有allOf
        // 这里有一个问题就是当其中一个执行完成会进入到下一阶段，但是未执行完成的线程还是会执行
        CompletableFuture<Object> future1Any = CompletableFuture.anyOf(future1FromSina, future1From163);

        // 第二阶段
        CompletableFuture<Double> future2FromSina = future1Any.thenApplyAsync(
            code -> fetchPrice((String) code, "https://finance.sina.com.cn/price/"));
        CompletableFuture<Double> future2From163 = future1Any.thenApplyAsync(
            code -> fetchPrice((String) code, "https://money.163.com/price/"));

        // 用anyOf合并为一个新的CompletableFuture:
        CompletableFuture<Object> future2Any = CompletableFuture.anyOf(future2FromSina, future2From163);

        // 最终结果:
        future2Any.thenAccept(result -> System.out.println("result: " + result));

        TimeUnit.SECONDS.sleep(30);
    }

    private static String queryCode(String name, String url) {
        System.out.println("query code from " + url + "...");
        try {
            Thread.sleep((long) (Math.random() * 100));
        } catch (InterruptedException e) {
        }
        return "601857";
    }

    private static Double fetchPrice(String code, String url) {
        System.out.println("query price from " + url + "...");
        try {
            Thread.sleep((long) (Math.random() * 100));
        } catch (InterruptedException e) {
        }
        return 5 + Math.random() * 20;
    }

    private static String queryCode(String name) {
        System.out.println("name: " + name);
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
        }
        return "601857";
    }

    private static Double fetchPrice() {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
        }
        if (Math.random() < 0.3) {
            throw new RuntimeException("fetch price failed!");
        }
        return 5 + Math.random() * 20;
    }

    private static Double fetchPrice(String code) {
        System.out.println("code: " + code);
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
        }
        return 5 + Math.random() * 20;
    }
}
```



















































