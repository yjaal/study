# 原子类

## `AtomicInteger`

一个简单的测试

```java
package concurrent.phase3;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerTest {

    private static Set<Integer> set = new HashSet<>();

    public static void main(String[] args) throws InterruptedException {
        AtomicInteger value = new AtomicInteger(0);
        Thread t1 = new Thread(() -> {
            int x = 0;
            while (x < 500) {
                int v = value.getAndIncrement();
                set.add(v);
                System.out.println(Thread.currentThread().getName() + ":" + v);
                x++;
            }
        });

        Thread t2 = new Thread(() -> {
            int x = 0;
            while (x < 500) {
                int v = value.getAndIncrement();
                set.add(v);
                System.out.println(Thread.currentThread().getName() + ":" + v);
                x++;
            }
        });

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(set.size());
    }
}
```

作为对比，我们可以将`value`换成普通类型，或者使用`volatile`修饰，会出现并发问题。

**`CAS`**

其实就是快速失败的作用，在`jdk6`中可以看到`getAndSet`方法实现为

```java
public final int getAndSet(int newValue) {
    for (; ; ) {
        int current = get();
        if (compareAndSet(current, newValue)) {
            return current;
        }
    }
}
------
//jdk8已经改成这样了
    public final int getAndSet(int var1) {
    return unsafe.getAndSetInt(this, valueOffset, var1);
}
```

通过代码很好理解，就是在返回值的时候先比较下当前值`current`是否已经被改变，这个`compareAndSet`是在`CPU`层面加锁，会很快，相当于一种无锁的状态。如果当前值一被改变就立即失败重来。

这里实现一个简单的无锁控制

```java
package concurrent.phase3;
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerTest1 {

    private final AtomicInteger value = new AtomicInteger(0);

    private static final AtomicIntegerTest1 lock = new AtomicIntegerTest1();

    private Thread lockedThread;

    public static void main(String[] args) {
        for (int i = 0; i < 2; i++) {
            new Thread(() -> {
                try {
                    doSomething();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }

    public static void doSomething() throws Exception {
        try {
            lock.tryLock();
            System.out.println(Thread.currentThread().getName() + " get the lock");
            Thread.sleep(100_000);
        } finally {
            lock.unlock();
        }
    }

    public void tryLock() throws Exception {
        //如果是0，表示锁为释放状态，否则为关闭状态
        boolean success = value.compareAndSet(0, 1);
        if (!success) {
            throw new RuntimeException("Get the lock failed");
        } else {
            lockedThread = Thread.currentThread();
        }
    }

    public void unlock() {
        if (0 == value.get()) {
            return;
        }
        if (lockedThread == Thread.currentThread()) {
            value.compareAndSet(1, 0);
        }
    }
}
```

这里首先会去获取锁，如果获取不到就释放掉当前线程。其他基本类型的原子类基本类似。



## `AtomicReference`

这个类可以让我们自定义的类变成原子类型的

```java
package concurrent.phase3;

import java.util.concurrent.atomic.AtomicReference;

public class AtomicReferenceTest {

    public static void main(String[] args) {
        AtomicReference<Simple> atomic = new AtomicReference<>(new Simple("Alext", 12));
        System.out.println(atomic.get());

        boolean res = atomic.compareAndSet(new Simple("aa", 13), new Simple("bb", 13));
        System.out.println(res);
    }

    static class Simple {

        private String name;
        private int age;

        public Simple() {
        }

        public Simple(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        @Override
        public String toString() {
            return "Simple{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
        }
    }
}
```



## `ABA` 问题

本来`CAS`通过检查当前值是否有改变来解决并发问题，但是当一个值变化为 `A->B->A`的时候其实变量值是有变化的，但是此时`CAS`是无法判断出来的，这就会导致问题。



## `AtomicStampedReference`

通过此对象可以解决上面的问题，其中有一个对象`Pair`，其中不仅保存了当前变量的值，还保存了一个时间戳，就算值相同，而时间戳不同也表明变量发生了变化。



## 原子类数组

```
AtomicIntegerArray
AtomicLongArray
AtomicReferenceArray
```

```java
package concurrent.phase3;

import java.util.concurrent.atomic.AtomicIntegerArray;

public class AtomicIntegerArrayTest {

    public static void main(String[] args) {
        AtomicIntegerArray arr = new AtomicIntegerArray(10);
        arr.set(0, 10);
        System.out.println(arr.get(0));
        System.out.println(arr.get(1));
    }
}
```

相关源码分析：`https://www.cnblogs.com/zyy1688/p/10654943.html`

```java
//获取int[]在内存中的初始地址。
private static final int base = unsafe.arrayBaseOffset(int[].class);
//用来存储移位个数
private static final int shift;
private final int[] array;

//初始化变量。
static {
    int scale = unsafe.arrayIndexScale(int[].class);
    if ((scale & (scale - 1)) != 0)
        throw new Error("data type scale not a power of two");
    //得出scale为2的几次方，即需要移位个数
    shift = 31 - Integer.numberOfLeadingZeros(scale);
}
//检查第i个元素的地址值。
private long checkedByteOffset(int i) {
    if (i < 0 || i >= array.length)
        throw new IndexOutOfBoundsException("index " + i);
    return byteOffset(i);
}
//当前索引i*shift(偏移位置) + base(基础位置)
private static long byteOffset(int i) {
    return ((long) i << shift) + base;
}
//获取第i个元素的值
public final int get(int i) {
    return getRaw(checkedByteOffset(i));
}
//通过地址值来获取偏移量的元素值。
private int getRaw(long offset) {
    return unsafe.getIntVolatile(array, offset);
}
//用cas方式，在元素i的位置设置新值
public final void set(int i, int newValue) {
    unsafe.putIntVolatile(array, checkedByteOffset(i), newValue);
}
```

并且数组里面各个元素类别都是相同的，所以占有的空间也都是一样大的，假设上面数组为`int`类型的`array`，并且`array`的地址为`n`，所以可以计算出`array[1]`为`base+4`，`array[2]`为 
`base+4*2`，`array[3]`为`base+4*3` 。 

所以这样在`AtomicIntegerArray`里面，我们可以通过`base，i，scale`和`shift`，能够计算出数组中任意元素的位置以及获取值，这样一来，对数组的操作就可以转化为对单个元素的操作。 
开始被一个问题困扰了一会儿，`array`数组是`final`类型，保证了：

- `array`在使用的时候，已经初始化了
- `array`不能再重新指向其他对象

但是，`array`数组里面并不是`volatile`类型的，能确保可见性么？

我们再来看看它的`get`方法和`set`方法： 

```java
public final int get(int i) {
    return getRaw(checkedByteOffset(i));
}
//volatile的get
private int getRaw(long offset) {
    return unsafe.getIntVolatile(array, offset);
}

//volatile的set
public final void set(int i, int newValue) {
    unsafe.putIntVolatile(array, checkedByteOffset(i), newValue);
}

//lazySet，即普通set，性能高
public final void lazySet(int i, int newValue) {
    unsafe.putOrderedInt(array, checkedByteOffset(i), newValue);
}

//原子性的获取并且set
public int getAndSet(int i, int newValue) {
    return unsafe.getAndSetInt(array, checkedByteOffset(i), newValue);
}
```

如上我们可以看到，调用的都是`unsafe`里面具有`volatile`语义的方法，也就是整个通过内存地址对数组元素的操作，也是有`volatile`语义的，即具有可见性。



## `AtomicIntegerFieldUpdater`

比如有一个类，其中有很多属性，但是我们不想对这个类使用`AtomicStampedReference`来封装，只是想对其中一个属性字段进行原子操作，此时就可以使用此类来完成。

```java
package concurrent.phase3;

import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;

public class Demo01 {

    public static void main(String[] args) {
        final AtomicIntegerFieldUpdater<TestMe> updater =
            AtomicIntegerFieldUpdater.newUpdater(TestMe.class, "i");
        final TestMe me = new TestMe();
        for (int i = 0; i < 2; i++) {
            new Thread(() -> {
                for (int j = 0; j < 20; j++) {
                    int v = updater.getAndIncrement(me);
                    System.out.println(Thread.currentThread().getName() + "->" + v);
                }
            }).start();
        }
    }

    static class TestMe{
        volatile int i ;
    }
}
```

这里要注意，如果属性 `i` 是 `private`(当前类不受此限制)，或者说实例 `me` 为 `null` ，则会报错。当然属性类型和名字如果不对，也会报错，同时要注意，属性字段需要使用 `volatile` 修饰。类似的还有`AtomicLongFieldUpdater、AtomicReferenceFieldUpdater`。**主要使用场景就是比如在对链表等数据结构中使用的时候，在多线程中如果我们直接对整个链表加锁，显然效率是很慢的，此时使用`AtomicIntegerFieldUpdater`就会好很多。**这在`ConcurrentHashMap`中是有用到的。

```java
package concurrent.phase3;

import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;

public class Demo02 {

    private volatile int i ;
    private AtomicIntegerFieldUpdater<Demo02> updater =
        AtomicIntegerFieldUpdater.newUpdater(Demo02.class, "i");

    public void update(int newValue) {
        updater.compareAndSet(this, i, newValue);
    }

    public int get() {
        return i;
    }

    public static void main(String[] args) {
        Demo02 demo02 = new Demo02();
        demo02.update(10);
        System.out.println(demo02.get());
    }
}
```



## `Unsafe`

```java
package concurrent.phase3;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import sun.misc.Unsafe;

public class Demo03 {

    public static void main(String[] args) throws Exception {
        ExecutorService service = Executors.newFixedThreadPool(1000);
//        Counter counter = new StupidCounter();
        Counter counter = new CasCounter();
        long start = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            service.submit(new CounterRunnable(counter, 10000));
        }
        service.shutdown();
        service.awaitTermination(1, TimeUnit.HOURS);
        long end = System.currentTimeMillis();
        System.out.println("Counter result:" + counter.getCounter());
        System.out.println("cost: " + (end - start));
    }

    interface Counter {

        void increment();

        long getCounter();
    }

    private static class CasCounter implements Counter {

        private volatile long counter = 0;

        private Unsafe unsafe;

        private long offset;

        public CasCounter() throws Exception {
            this.unsafe = Unsafe.getUnsafe();
            this.offset = unsafe.objectFieldOffset(CasCounter.class.getDeclaredField("counter"));
        }

        @Override
        public void increment() {
            long current = counter;
            while (!unsafe.compareAndSwapLong(this, offset, current, current + 1)) {
                current = counter;
            }
        }

        @Override
        public long getCounter() {
            return counter;
        }
    }

    private static class StupidCounter implements Counter {

        private long counter = 0;

        @Override
        public void increment() {
            counter++;
        }

        @Override
        public long getCounter() {
            return counter;
        }
    }

    private static class CounterRunnable implements Runnable {

        private final Counter counter;
        private final int num;

        public CounterRunnable(Counter counter, int num) {
            this.counter = counter;
            this.num = num;
        }

        @Override
        public void run() {
            for (int i = 0; i < num; i++) {
                counter.increment();
            }
        }
    }
}
```

这里有两个实现，对于`StupidCounter`我们还可以在其方法上加锁来进行测试，另外一个实现是使用`Unsafe`类来实现无锁，但是在`jdk8`中无法使用，可以切换到低版本。或者使用反射来获取`Unsafe`。

```java
private static Unsafe getUnsafe() {
    try {
        Field f = Unsafe.class.getDeclaredField("theUnsafe");
        f.setAccessible(true);
        return (Unsafe) f.get(null);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
```

还有一些不推荐的用法

```java
package concurrent.phase3;

import java.io.File;
import java.io.FileInputStream;
import java.lang.reflect.Field;
import sun.misc.Unsafe;

public class Demo04 {

    public static void main(String[] args) throws Exception {
        //此种情况下类会被初始化
        // Simple simple = Simple.class.newInstance();

        //这样则不会被初始化
        //Class.forName("concurrent.phase3.Demo04$Simple");

        //这样也可以绕过初始化
        Unsafe unsafe = getUnsafe();
        //直接开辟了一块内存
        Simple simple = (Simple) unsafe.allocateInstance(Simple.class);
        System.out.println(simple.getI());
        System.out.println("Simple类加载器： " + simple.getClass().getClassLoader());

        System.out.println("-----------------");

        Guard guard = new Guard();
        //此时是不会输出的
        guard.work();
        //这里通过Unsafe改变内存中ACCESS_ALLOWED的值
        Field field = guard.getClass().getDeclaredField("ACCESS_ALLOWED");
        //这里第一个参数是guard类实例，然后第二个参数是字段属性的偏移量，这样就可以找到
        //该属性所在内存中的位置，然后将值设置进去
        unsafe.putInt(guard, unsafe.objectFieldOffset(field), 42);
        guard.work();

        System.out.println("-----------------");

        //使用Unsafe跳过类加载器加载一个类，不过会初始化
        byte[] bytes = loadClassContent();
        Class<?> clazz = unsafe.defineClass(null, bytes, 0, bytes.length, null, null);
        Integer value = (Integer) clazz.getMethod("getI").invoke(clazz.newInstance(), null);
        System.out.println(value);

        System.out.println("-----------------");
    }

    private static byte[] loadClassContent() throws Exception{
        File file = new File("D:\\Simple.class");
        FileInputStream fis = new FileInputStream(file);
        byte[] content = new byte[(int) file.length()];
        fis.read(content);
        fis.close();
        return content;
    }

    private static Unsafe getUnsafe() {
        try {
            Field f = Unsafe.class.getDeclaredField("theUnsafe");
            f.setAccessible(true);
            return (Unsafe) f.get(null);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static class Simple {

        private long i = 0;

        public Simple() {
            this.i = 1;
            System.out.println("初始化: " + i);
        }

        public long getI() {
            return i;
        }
    }

    private static class Guard {

        private int ACCESS_ALLOWED = 1;

        private boolean allow() {
            return 42 == ACCESS_ALLOWED;
        }

        public void work() {
            if (allow()) {
                System.out.println("允许执行");
            }
        }

    }
}
```

这里相关方法不推荐使用，但是需要理解，因为在后面的`AQS`中有用到，特别是获取到一个实例对象的某个字段在内存中的偏移量，通过这个偏移量我们可以拿到该字段在内存中的位置。



# `AQS`

并发包基本都是基于`AQS`，这里先看下`AQS`的基本实现

| 属性              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `int waitStatus`  | 1）`CANCELLED = 1`，表示当前结点已取消调度。当`timeout`或被中断（响应中断的情况下），<br/>会触发变更为此状态，进入该状态后的结点将不会再变化。<br/>2）`SIGNAL = -1`，表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为`SIGNAL`。<br/>3）`CONDITION = -2`，表示结点等待在`Condition`上，当其他线程调用了`Condition`的`signal()`方法后，<br/>`CONDITION`状态的结点将从等待队列转移到同步队列中，等待获取同步锁；<br/>4）`PROPAGATE = -3`，共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点，一直往后；<br/>5）`INITIAL = 0`，初始状态 |
| `Node prev`       | 前驱节点(`predecessor`)                                      |
| `Node next`       | 后继节点(`successor`)                                        |
| `Node nextWaiter` | 等待队列中的后继节点，如果当前节点是共享的，就是`SHARED`，否则是独享的`EXCLUSIVE` |
| `Thread thread`   | 获取同步状态的线程                                           |



`AQS`的实现依赖内部的同步队列（`FIFO`双向队列），如果当前线程获取同步状态失败，`AQS`会将该线程以及等待状态等信息构造成一个`Node`，将其加入同步队列的尾部，同时阻塞当前线程，当同步状态释放时，唤醒队列的头节点。

上面说的有点抽象，来具体看下，首先来看`AQS`最主要的三个成员变量：

```
    private transient volatile Node head;
    
    private transient volatile Node tail;

    private volatile int state; 
```



上面提到的同步状态就是这个`int`型的变量`state`。`head`和`tail`分别是同步队列的头结点和尾结点。假设`state=0`表示同步状态可用（如果用于锁，则表示锁可用），`state=1`表示同步状态已被占用（锁被占用）。

下面举例说下获取和释放同步状态的过程：

**获取同步状态**

假设线程`A`要获取同步状态（这里想象成锁，方便理解），初始状态下`state=0`,所以线程A可以顺利获取锁，`A`获取锁后将`state`置为1。在`A`没有释放锁期间，线程`B`也来获取锁，此时因为`state=1`，表示锁被占用，所以将`B`的线程信息和等待状态等信息构成出一个`Node`节点对象，放入同步队列，`head`和`tail`分别指向队列的头部和尾部（此时队列中有一个空的`Node`节点作为头点，`head`指向这个空节点，空`Node`的后继节点是`B`对应的`Node`节点，`tail`指向它），同时阻塞线程B(这里的阻塞使用的是`LockSupport.park()`方法)。后续如果再有线程要获取锁，都会加入队列尾部并阻塞。

```mermaid
graph LR;
  Head-->B
  Tail-->B
```



**释放同步状态**

当线程`A`释放锁时，即将`state`置为`0`，此时A会唤醒头节点的后继节点（所谓唤醒，其实是调用`LockSupport.unpark(B)`方法），即`B`线程从`LockSupport.park()`方法返回，此时`B`发现`state`已经为0，所以B线程可以顺利获取锁，`B`获取锁后`B`的`Node`节点随之出队。



![1](./assert/1.png)

总体逻辑就是：每个节点只关注自己的前驱节点，如果前驱节点是`head`，那就说明当前节点可以去抢锁了，用`tryAcquire`去抢。

要是抢到了，就把这个节点作为`head`，同时移除掉原有的`head`。（`head`节点是没有数据的，就是一个队列起始的标志）。于是下一个节点成为了`head`指向的节点。那要是没抢到呢？那就看看自己是不是可以休息了：`shouldParkAfterFailedAcquire`，如果能休息就`park`进入`waiting`状态,直到被`unpark`。





## 独占锁

（1）获取锁的实现

`AQS`的锁功能齐全，它既可以用来实现独占锁，也可以用来实现共享锁。

* 独占锁：也叫排他锁，即锁只能由一个线程获取，若一个线程获取了锁，则其他想要获取锁的线程只能等待，直到锁被释放。比如说写锁，对于写操作，每次只能由一个线程进行，若多个线程同时进行写操作，将很可能出现线程安全问题；

* 共享锁：锁可以由多个线程同时获取，锁被获取一次，则锁的计数器+1。比较典型的就是读锁，读操作并不会产生副作用，所以可以允许多个线程同时对数据进行读操作，而不会有线程安全问题，当然，前提是这个过程中没有线程在进行写操作；

我们首先分析一下独占锁。在`AQS`中，通过方法`acquire`来获取独占锁，`acquire`方法的代码如下：

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

* 首先调用`tryAcquire`尝试获取一次锁，若返回`true`，表示获取成功，则`acquire`方法将直接返回；若返回`false`，则会继续向后执行`acquireQueued`方法；

* `tryAcquire`返回`false`后，将执行`acquireQueued`，但是这个方法传入的参数调用了`addWaiter`方法；

* `addWaiter`方法的作用是将当前线封装成同步队列的节点，然后加入到同步队列的尾部进行排队，并返回此节点；

* `addWaiter`方法执行完成后，将它的返回值作为参数，调用`acquireQueued`方法。`acquireQueued`方法的作用是让当前线程在同步队列中阻塞，然后在被其他线程唤醒时去获取锁；

* 若线程被唤醒并成功获取锁后，将从`acquireQueued`方法中退出，同时返回一个boolean值表示当前线程是否被中断，若被中断，则会执行下面的`selfInterrupt`方法，响应中断；

下面我们就来具体分析这个方法中调用的几个方法的执行流程。首先第一个`tryAcquire`方法是一个抽象方法，需要子类来实现，这里应用了模板模式。

```java
// 将线程封装成一个节点，放入同步队列的尾部
private Node addWaiter(Node mode) {
    // 当前线程封装成同步队列的一个节点Node
    Node node = new Node(Thread.currentThread(), mode);
    // 这个节点需要插入到原尾节点的后面，所以我们在这里先记下原来的尾节点
    Node pred = tail;
    // 判断尾节点是否为空，若为空表示队列中还没有节点，则不执行以下步骤
    if (pred != null) {
        // 记录新节点的前一个节点为原尾节点
        node.prev = pred;
        // 将新节点设置为新尾节点，使用CAS操作保证了原子性
        if (compareAndSetTail(pred, node)) {
            // 若设置成功，则让原来的尾节点的next指向新尾节点
            pred.next = node;
            return node;
        }
    }
    // 若以上操作失败，则调用enq方法继续尝试(enq方法见下面)
    enq(node);
    return node;
}

private Node enq(final Node node) {
    // 使用死循环不断尝试
    for (;;) {
        // 记录原尾节点
        Node t = tail;
        // 若原尾节点为空，则必须先初始化同步队列，初始化之后，下一次循环会将新节点加入队列
        if (t == null) { 
            // 使用CAS设置创建一个默认的节点作为首节点
            if (compareAndSetHead(new Node()))
                // 首尾指向同一个节点
                tail = head;
        } else {
            // 以下操作与addWaiter方法中的if语句块内一致
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

它的执行过程大致可以总结为：将新线程封装成一个节点，加入到同步队列的尾部，若同步队列为空，则先在其中加入一个默认的节点，再进行加入；若加入失败，则使用死循环（也叫自旋）不断尝试，直到成功为止。这个过程中使用`CAS`保证了添加节点的原子性。下面看看`acquireQueued`方法的源码：

```java
/**
 * 让线程不间断地获取锁，若线程对应的节点不是头节点的下一个节点，则会进入等待状态
 */
final boolean acquireQueued(final Node node, int arg) {
    // 记录失败标志
    boolean failed = true;
    try {
        // 记录中断标志，初始为true
        boolean interrupted = false;
        // 循环执行，因为线程在被唤醒后，可能再次获取锁失败，需要重写进入等待
        for (;;) {
            // 获取当前线程节点的前一个节点
            final Node p = node.predecessor();
            // 若前一个节点是头节点，则tryAcquire尝试获取锁，若获取成功，则执行if中的代码
            //只有当前线程的前一个节点时头节点时才能去获取锁
            if (p == head && tryAcquire(arg)) {
                // 将当前节点设置为头节点
                setHead(node);
                // 将原来的头节点移出同步队列
                p.next = null; // help GC
                // 失败标志置为false
                failed = false;
                // 返回中断标志，acquire方法可以根据返回的中断标志，判断当前线程是否被中断
                return interrupted;
            }
            // shouldParkAfterFailedAcquire方法判断当前线程是否能够进入等待状态，
            // 若当前线程的节点不是头节点的下一个节点，则需要进入等待状态，
            // 在此方法内部，当前线程会找到它的前驱节点中，第一个还在正常等待或执行的节点，
            // 让其作为自己的直接前驱，然后在需要时将自己唤醒（因为其中有些线程可能被中断），
            // 若找到，则返回true，表示自己可以进入等待状态了；
            
            // 然后继续调用parkAndCheckInterrupt方法，当前线程在这个方法中等待，
            // 直到被其他线程唤醒，或者被中断后返回，返回时将返回一个boolean值，
            // 表示这个线程是否被中断，若为true，则将执行下面一行代码，将中断标志置为true
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        // 上面代码中只有一个return语句，且return的前一句就是failed = false;
        // 所以只有当异常发生时，failed才会保持true的状态运行到此处；
        // 异常可能是线程被中断，也可能是其他方法中的异常，
        // 比如我们自己实现的tryAcquire方法
        // 此时将取消线程获取锁的动作，将它从同步队列中移除
        if (failed)
            cancelAcquire(node);
    }
}
```

以上就是`acquireQueued`方法的源码分析。这个方法的作用可以概括为：让线程在同步队列中阻塞，直到它成为头节点的下一个节点，被头节点对应的线程唤醒，然后开始获取锁，若获取成功才会从方法中返回。这个方法会返回一个`boolean`值，表示这个正在同步队列中的线程是否被中断。

```java
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)
        /*
        * 这里就是说，前驱节点的等待状态时SIGNAL，执行完了会通知当前节点，此时当前节点可以休息了
        */
        return true;
    if (ws > 0) {
        /*
         * 前驱节点状态 > 0，回头看看开始的表格，只有CANCELED是1大于0，表示前驱节点取消了，
         * 此时一直往前找，直到找到一个状态<=0（没被取消）的节点，放它后面
        */
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else {
        /*
        * ws < 0，就是说前驱节点是正常的，那就把前驱节点状态设置成SIGNAL，让前驱节点执行完后通知当前节点
        */
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
```

后面的`parkAndCheckInterrupt`方法会将线程中断，进入等待状态，这和调用`Thread.interrupted()`不同，此方法只是设置中断状态为`true`，并不一定真的中断线程，而`parkAndCheckInterrupt`是给`CPU`发送指令进行中断，然后会检查中断状态。

（2）释放锁

释放独占锁是通过`release`方法实现的：

```java
public final boolean release(int arg) {
    // 调用tryRelease尝试修改state释放锁，若成功，将返回true，否则false
    //tryRelease需要自己复写
    if (tryRelease(arg)) {
        // 若修改state成功，则表示释放锁成功，需要将当前线程移出同步队列
        // 当前线程在同步队列中的节点就是head，所以此处记录head
        Node h = head;
        // 若head不是null，且waitStatus不为0，表示它是一个装有线程的正常节点，
        // 在之前提到的addWaiter方法中，若同步队列为空，则会创建一个默认的节点放入head
        // 这个默认的节点不包含线程，它的waitStatus就是0，所以不能释放锁
        if (h != null && h.waitStatus != 0)
            // 若head是一个正常的节点，则调用unparkSuccessor唤醒它的下一个节点所对应的线程
            unparkSuccessor(h);
        // 释放成功
        return true;
    }
    // 释放锁失败
    return false;
}
```



```java
private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws < 0)
        //清空当前节点的状态为初始状态0
        compareAndSetWaitStatus(node, ws, 0);

    Node s = node.next;
    //如果后继节点为空，或者已经被取消
    if (s == null || s.waitStatus > 0) {
        s = null;
        //从后向前遍历，找到最前面的一个等待的线程节点，因为这里后继节点为空
        //没法从前向后遍历
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    //后继节点不为空就直接唤醒
    if (s != null)
        LockSupport.unpark(s.thread);
}
```



## 共享锁

（1）获取锁

在`AQS`中，定义了`acquireShared`方法用来获取共享锁：

```java
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0)
        doAcquireShared(arg);
}
```

可以看到，这个方法比较简短。首先调用`tryAcquireShared`方法尝试获取一次共享锁，即修改`state`的值，若返回值`>=0`，则表示获取成功，线程不受影响，继续向下执行；若返回值小于0，表示获取共享锁失败，则线程需要进入到同步队列中等待，调用`doAcquireShared`方法。`acquireShared`方法也是`AQS`的一个模板方法，而其中的`tryAcquireShared`方法就是需要使用者自己实现的方法。下面我们来看看`doAcquireShared`方法的实现：

```java
/**
 * 不间断地获取共享锁，若线程对应的节点不是头节点的下一个节点，将进入等待状态
 * 实现与acquireQueued非常类似
 * @param arg the acquire argument
 */
private void doAcquireShared(int arg) {
    // 往同步队列的尾部添加一个默认节点，Node.SHARED是一个Node常量，
    // 它的值就是一个不带任何参数的Node对象，也就是new Node();
    final Node node = addWaiter(Node.SHARED);
    // 失败标志，默认为true
    boolean failed = true;
    try {
        // 中断标志，用来判断线程在等待的过程中释放被中断
        boolean interrupted = false;
        // 死循环不断尝试获取共享锁
        for (;;) {
            // 获取默认节点的前一个节点
            final Node p = node.predecessor();
            // 判断当前节点的前一个节点是否为head节点
            if (p == head) {
                // 尝试获取共享锁
                int r = tryAcquireShared(arg);
                // 若r>0，表示获取成功
                if (r >= 0) {
                    // 当前线程获取锁成功后，调用setHeadAndPropagate方法将当前线程设置为head
                    // 同时，若共享锁还能被其他线程获取，则在这个方法中也会向后传递，唤醒后面的线程
                    setHeadAndPropagate(node, r);
                    // 将原来的head的next置为null
                    p.next = null; // help GC
                    // 判断当前线程是否中断，若被中断，则调用selfInterrupt方法响应中断
                    if (interrupted)
                        selfInterrupt();
                    // 失败标志置为false
                    failed = false;
                    return;
                }
            }
            // 以下代码和获取独占锁的acquireQueued方法相同，即让当前线程进入等待状态
            // 具体解析可以看上面acquireQueued方法的解析
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

`doAcquireShared`方法的实现和获取独占锁中的`acquireQueued`方法很类似，但是主要有一点不同，那就是**线程在被唤醒后，若成功获取到了共享锁，还需要判断共享锁是否还能被其他线程获取，若可以，则继续向后唤醒它的下一个节点对应的线程**。



（2）释放锁

```java
public final boolean releaseShared(int arg) {
    // 尝试修改state的值释放锁
    if (tryReleaseShared(arg)) {
        // 若成功，则调用以下方法唤醒后继节点中的线程
        doReleaseShared();
        return true;
    }
    return false;
}
```

`releaseShared`也是一个模板方法，它通过调用使用者自己实现的`tryReleaseShared`方法尝试释放锁，修改`state`的值，若返回`true`，表示修改成功，则继续向下调用`doReleaseShared`唤醒`head`的下一个节点对应的线程，让它开始尝试获取锁；若修改`state`失败，则返回`false`。

```java
private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                //释放下一个节点
                unparkSuccessor(h);
            }
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        if (h == head)                   // loop if head changed
            break;
    }
}
```

这里要注意最后的判断，这里是为了防止在新节点加入的过程中头节点发生了变化，所以需要比较，如果没变就直接释放，否则需要再次循环一次。



## `acquireInterruptibly`

同步器提供了 `acquireInterruptibly` 方法来进行**可响应中断的获取锁操作**

```java
public final void acquireInterruptibly(int arg)
    throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    //尝试获取锁
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}
private void doAcquireInterruptibly(int arg)
    throws InterruptedException {
    //将当前节点计入到同步队列尾
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                //这里直接异常
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

仔细观察可以发现该方法实现源码和上文中 `acquireQueued` 方法的实现基本上类似，只是这里把入队操作 `addWaiter` 放到了方法里面了，还有一个区别就是当在循环体内判断需要进行中断时会直接抛出异常来响应中断

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```





## `hasQueuedPredecessors`

**此方法是公平锁加锁时判断等待队列中是否存在有效节点（也就是有线程在队列中等待）的方法**。如果返回`False`，说明当前线程可以争取共享资源；如果返回`True`，说明队列中存在有效节点，当前线程必须加入到等待队列中。

注意：此方法相当于一种测试，但是在测试过程中可能情况已变，最终结果取决于最后我们获取锁的实际情况，这里相当于一种快速失败的方式。

```java
public final boolean hasQueuedPredecessors() {
    /*
      需要时刻认为CLH队列一直都在动态的变化中，head和tail随时会发生变化在构建CLH链表时，
      初始化时是先设置head，然后设置tail，那么如果有null的情况则只有 head!=null && tail==null，
      一旦在这个时刻添加尾节点成功，head.next 的值其实已经变化了，但是如果先获取head可能存在null的
      情况，所以先获取tail再获取head
      */
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

要理解此方法，则先要看入队操作

```java
private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;//这里只是执行一个快速操作，它和enq里的else分支的逻辑一样
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);//如果上面快速操作没有成功，再执行enq
    return node;
}

private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) { // 第一次入队，没有虚拟节点的存在，需先创建它
            if (compareAndSetHead(new Node()))
                tail = head;
        } else { // 至少有一个node，尝试入队
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```



1、分析 `h != t` 返回 `false` 的情况。此时 `hasQueuedPredecessors` 返回 `false`。

* 当 `h` 和 `t` 都为 `null` ，返回 `false` 。此时说明队列为空，还从来没有 `Node`入过队。

* 当 `h` 和 `t` 都指向同一个`Node`，也返回 `false`。此时说明队列中只有一个正在运行的线程节点，那说明没有线程在队列中。


2、分析 `h != t` 返回 `true` ，且 `(s = h.next) == null` 返回 `true`，直接短路后面。此时` hasQueuedPredecessors` 返回 `true`。

* 既然 `h != t `返回 `true `，说明 `h `和 `t `不相等，先考虑特殊情况（上面讲到的出现“ `head不为null，tail为null” `的情况，此时 `head `是空 `node `， `next `成员肯定为 `null `），那么说明有一个线程正在执行 `enq `，且它正好执行到 `if (compareAndSetHead(new Node()))到tail = head; `的间隙。但这个线程肯定不是当前线程，所以不用判断后面短路的 `s.thread != Thread.currentThread() `了，因为当前线程连 `enq `都没开始执行，但另一个线程都开始执行 `enq `了，那不就是说明当前线程排在别人后面了，别的线程马上就要入队了。
* 既然 `h != t `返回 `true `，说明 `h `和 `t `不相等，再考虑二者都不为 `null `。那此时队列中已经至少有一个等待中的线程了，那说明当前线程肯定排在别人后面了。

3、分析 `h != t `返回 `true `，且 `(s = h.next) == null `返回 `false `，且 `s.thread != Thread.currentThread() `返回 `true `。此时 `hasQueuedPredecessors `返回 `true `。如果 `s.thread != Thread.currentThread() `返回 `false `。此时 `hasQueuedPredecessors `返回 `false `。

现在知道 `head `不为 `null `，而且 `head.next `也不为 `null `了（ `(s = h.next) == null返回false `）。我们也知道队列中第一个等待的线程存放在 `head.next `里（注意， `head `为虚拟节点，不存放线程），那么如果 `head.next `的线程不是当前线程，那即说明当前线程已经排在别人线程后面了。



## `ConditionObject`

参考：`https://blog.csdn.net/qq_36582604/article/details/105849161`

此类的主要作用就是对应之前使用` synchronized` 时才能使用的` wait` 和` notify` 方法。

### 属性

```java
/** First node of condition queue. */
private transient Node firstWaiter;
/** Last node of condition queue. */
private transient Node lastWaiter;
```

每个条件变量都维护了一个容器，` ConditionObject` 中的容器就是单向链表队列，上面的属性就是队列的头结点` firstWaiter` 和尾结点` lastWaiter` ，需要注意，条件队列中的头结点不是虚拟头结点，而是包装了等待线程的节点！其类型和同步队列一样，也是使用` AQS` 的内部类` Node` 来构成，但与同步队列不同的是，条件队列是一个单向链表，所以他并没有使用` Node` 类中的` next` 属性来关联后继` Node` ，而使用的` nextWaiter` 

```java
volatile Node prev;
volatile Node next;
Node nextWaiter;
```

这里我们需要注意，` nextWaiter` 是没用` volatile` 修饰的，为什么呢？因为线程在调用` await` 方法进入条件队列时，是已经拥有了锁的，此时是不存在竞争的情况，所以无需通过` volatile` 和` cas` 来保证线程安全。而进入同步队列的都是抢锁失败的，所以肯定是没有锁的，故要考虑线程安全。最后需要注意一点的是，条件队列里面的` Node` 只会存在` CANCELLED` 和` CONDITION` 的状态


### `signal/signalAll`

将条件队列中的所有` Node` 移到同步队列中，然后根据条件再唤醒它们去尝试获得锁

```java
public final void signalAll() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignalAll(first);
}
```

首先我们会通过我们子类复写的方法` isHeldExclusively` 来看此时的线程是否已经获得了锁。前面说过只有获得了锁的线程才能够去唤醒条件队列中的` Node` 。如果获得了锁，我们会判断条件队列的头结点是否为` null` ，为` null` 则说明条件队列中没有阻塞的` Node` ；如果不为` null` ，则会通过` doSignalAll` 方法来将条件队列中的所以` Node` 移动到同步队列中

```java
private void doSignalAll(Node first) {
    lastWaiter = firstWaiter = null;
    do {
       // 将next指向first的后继Node
        Node next = first.nextWaiter;
       // 切断first与后继Node的联系
        first.nextWaiter = null;
       // 将此node转移到同步队列中
        transferForSignal(first);
        // 将first指向first的后继Node
        first = next;
    // 在判断此时的first是否为null，不是则继续循环
    } while (first != null);
}
```

因为是移出条件队列中所有的` Node` ，所以一开始我们通过将头结点和尾节点置为` null` 来“清空”条件队列，然后通过` do-while` 循环将条件队列中所有节点通过` transferForSignal` 方法一个一个转移到同步队列中

```java
final boolean transferForSignal(Node node) {
    // 说明此节点状态为CANCELLED,所以跳过该节点（GC会回收）
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;
    // 入队方法（独占锁获取中详细阐述过）
    Node p = enq(node);
    int ws = p.waitStatus;
    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread); 
    return true;
}
```

我们首先会通过` CAS` 操作来将` Node` 的状态置为0，如果失败了，说明此时` Node` 状态是` CANCELLED` ，则我们跳过，返回` false` ；如果` Node` 状态成功置为了0，我们就通过` enq` 方法进行入队，这里还是需要提醒一下，` enq` 返回的是` Node` 的前驱节点。然后我们会根据前驱节点的状态来看此时是否要唤醒此节点，如果是下面这两种情况，则会将其唤醒，去尝试获取锁

* 如果前驱节点状态是` CANCELLED` 

* 前驱节点不是` CANCELLED` 状态，但` CAS` 将状态变为` SIGNAL` 失败

如果将前驱节点赋值` SIGNAL` 成功了，则该节点就需要等到前驱节点释放锁之后被唤醒了，我们需要注意，只要节点状态不是` CANCELLED` ，` transferForSignal` 方法最后都是返回` true` 。

` signalAll` 是将条件队列中所有的Node转移到同步队列，**` signal` 则只转移条件队列中的第一个状态不为` CANNCELLED` 的` Node` **



### `await`

**将节点入队并阻塞，等到其他线程唤醒(` signal` )或者自身中断后再重新去获取锁**

```java
public final void await() throws InterruptedException {
    // 如果此线程被中断过，直接抛中断异常
    if (Thread.interrupted())
        throw new InterruptedException();
    // 将当前线程包装成节点放入条件队列
    Node node = addConditionWaiter();
    // 释放当前线程持有的锁
    long savedState = fullyRelease(node);
    // 初始化中断模式参数
    int interruptMode = 0;
    // 检查节点是否在同步队列中
    while (!isOnSyncQueue(node)) {
       // 不在同步队列中则阻塞此线程
        LockSupport.park(this);
        // 上面会被阻塞，之后被唤醒后继续执行
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    // 被唤醒后继续执行，再去获取锁
    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    // 当线程是被中断唤醒时，node和后继节点是没有断开的
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    // 根据异常标志位对异常进行处理
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}

private Node addConditionWaiter() {
    Node t = lastWaiter;
    // If lastWaiter is cancelled, clean out.
    if (t != null && t.waitStatus != Node.CONDITION) {
        unlinkCancelledWaiters();
        t = lastWaiter;
    }
    Node node = new Node(Thread.currentThread(), Node.CONDITION);
    if (t == null)
        firstWaiter = node;
    else
        t.nextWaiter = node;
    lastWaiter = node;
    return node;
}
```

首先我们会把节点t指向` lastWaiter` ，如果` lastWaiter` 不是` null` 且它的等待状态不是` CONDITION` ，说明` lastWaiter` 的状态是` CANCELLED` ，所以我们会通过` unlinkCancelledWaiters` 方法来移除条件队列中所有` CANCELLED` 的节点，然后将t指向新的` lasterWaiter` ，所以我们可以看到，只要尾结点是` CANCELLED` ，就会将条件队列的所有` CANCELLED` 节点移除。

然后我们会将当前线程包装成一个节点，但是与同步队列初始化节点时不同，条件队列新建节点时会把状态置为` CONDITION` ，而同步队列则是默认值0，所以条件队列中的节点只有` CONDITION` 和` CANCELLED` 两种状态。然后我们再会判断下尾结点是否为` null` ，为` null` 说明条件队列为空，所以我们就将` firstWaiter` 指向新的节点；如果不为` null` ，就将尾结点的后继节点指向新节点，然后再重置` lastWaiter` 。最后将新节点返回。


```java
private void unlinkCancelledWaiters() {
    Node t = firstWaiter;
    Node trail = null;
    while (t != null) {
        Node next = t.nextWaiter;
        if (t.waitStatus != Node.CONDITION) {
            t.nextWaiter = null;
            if (trail == null)
                firstWaiter = next;
           else
                trail.nextWaiter = next;
 
            if (next == null)
                lastWaiter = trail;
         }
           else
            trail = t;
        t = next;
    }
}
```

这个就是从头结点往后遍历，将**所有**` Node` 状态为不为` CONDITION` 的节点移除队列。



```java
final long fullyRelease(Node node) {
    boolean failed = true;
    try {
        long savedState = getState();
        if (release(savedState)) {
            failed = false;
            return savedState;
        } else {
            throw new IllegalMonitorStateException();
        }
    } finally {
        if (failed)
            node.waitStatus = Node.CANCELLED;
    }
}
```

其中释放锁成功调用的是` release` 方法，这个方法在"独占锁的释放"中详述过，需要注意，` release` 除了释放线程的锁外，还会将同步队列中的第一个状态不为` CANCELLED` 的节点中的线程唤醒。最终如果释放锁成功，我们就会将` failed` 状态置为` false` ，然后返回` savedState` 状态，否则我们就会抛出异常。

我们最后看下` finally` ，如果释放锁失败，我们此线程会抛异常终止，那我们这个线程所在的节点状态就被置为` CANCELLED` ，然后等待后面被移出条件队列，所以这也是我们在` addConditonWaiter` 方法中为什么要检查尾结点是否为` CANCELLED` 的原因。

还需要注意的一点是` release` 的入参` savedState` ，这个是获取重入锁的数量，不管之前获得过多少次锁，` release` 方法都会一起释放掉（独占锁最多也就一个锁），这也是为什么这个方法起名为` fullyRelease` 的原因。

```java
final boolean isOnSyncQueue(Node node) {
    //condition装填，或前置节点为null，表明在条件队列中
    if (node.waitStatus == Node.CONDITION || node.prev == null)
        return false;
    if (node.next != null) // If has successor, it must be on queue
        return true;        
    return findNodeFromTail(node);
}
```

先看第一个` if` 语句，如果状态是` CONDITION` 或者` prev` 参数是` null` ，说明此节点是在条件队列中，返回为` false` 。我们知道，` prev` 和` next` 都是同步队列中使用的，所以如果两个属性不为` null` ，说明此节点是在同步队列中，因此第二个if条件成立则需要返回` true` 。如果两个` if` 都不成立，说明这个节点状态是0且` prev` 不为` null` ，即我们在"独占锁获取"中` CAS` 进入同步队列的情况，则我们会通过` findNodeFromTail` 方法来确认是不是这种情况

```java
private boolean findNodeFromTail(Node node) {
    Node t = tail;
    for (;;) {
        if (t == node)
            return true;
        if (t == null)
            return false;
        t = t.prev;
    }
}
```

如果此时` tail` 就是` node` 的话，说明` node` 在同步队列中，如果不是就像前遍历，但是这里大家可能有疑问，这个方法没有考虑到` CAS` 失败的情况，所以可能存在遍历不到的情况，我们看下作者对这个方法的注释。

然后看被唤醒后的操作。线程在这里被唤醒有两种情况，一种是其他线程调用了` doSignal` 或` doSignalAll` ，还有一种就是线程被中断（这两种最终都是调用了` unpark` 方法）。因为在` java` 中，线程被中断后并不是马上就去执行` unpark` 操作，而是先将线程标志位置为` true` 告诉操作系统我需要被中断，至于系统什么时候来执行中断，我们也不清楚，所以在这里，我们需要判断我们被唤醒的原因到底是因为中断还是别的线程唤醒的。这里我们通过` checkInterruptWhileWaiting` 方法来判断，但在讲这个方法前，我们需要先了解这个` interruptMode` 有几种状态

```java
/** Mode meaning to reinterrupt on exit from wait */
private static final int REINTERRUPT =  1;
/** Mode meaning to throw InterruptedException on exit from wait */
private static final int THROW_IE    = -1;
```

除了上面两种，还有一种初始态0，它代表线程没有被中断过，不做任何处理。` REINTERRUPT` 代表` await` 方法退出时，会重新再中断一次；而` THROW_IE` 则代表` await` 方法退出时，会抛出` InterruptedException` 异常。了解了状态后，我们来看方法

```java
private int checkInterruptWhileWaiting(Node node) {
    return Thread.interrupted() ?
        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
        0;
}
```

我们先看到注释，如果中断先于其他线程调用` signal` 等方法唤醒的，则应该返回` THROW_IE` ，而中断是后于其他线程调用` signal` 等方法唤醒，则返回` REINTERRUPT` 。

我们看下代码，代码就是一个嵌套的三元运算符，首先我们会检查中断标志位，如果` interrupted` 方法返回` false` ，说明没发生中断，则返回0；如果返回了` true` ，则说明中断了，则我们需要通过` transferAfterCancelledWait` 方法进一步检查是否发生了其他线程执行了唤醒操作

```java
final boolean transferAfterCancelledWait(Node node) {
    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) { 
        enq(node);
        return true;
    }
 
    while (!isOnSyncQueue(node))
        Thread.yield();
    return false;
}
```

我们先看第一个if条件，如果条件中的` CAS` 操作成功，说明此时的` Node` 肯定是在条件队列中，则我们调动 ` enq ` 方法将此节点放入到同步队列中，然后返回` true` ，但是这里需要特别注意，这个节点的` nextWaiter` 还没置为` null` 。如果` CAS` 失败了，说明这个节点可能已经在同步队列中或者在入队的过程中，所以我们通过循环等待此节点入队后返回` false` 。我们再回到调用` transferAfterCancelled` 的` checkInterruptWhileWaiting` 方法中，根据` transferAfterCancelledWait` 方法返回值我们最终会返回` REINTERRUPT` 或` THROW_IE` 。

回到` await` 方法

```java
public final void await() throws InterruptedException {
// 代码省略
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this); 
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) // 我们现在在这里！！！
            break;
    }
    //这里和之前独占锁的获取锁方式一样
    //让节点去获取锁，并且如果在获取锁的过程中被中断了，且此线程之前没被中断过，则将interruptMode置为REINTERRUPT
    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    // 还记得开始说的transferAfterCancelledWait方法吗，当线程是被中断唤醒时，
    // node和后继节点是没有断开的，这一步我们的节点中的线程已经获取锁了且从同步队
    // 列中移除了，所以我们在这里将此节点也移除条件队列，unlinkCancelledWaiters
    // 方法前面说过，它会将条件队列中所有不为CONDITION的的节点移除
    if (node.nextWaiter != null) 
        unlinkCancelledWaiters();
    // 如果interruptMode不为0，说明线程是被中断过的，所以需要对中断进行处理
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}
// 如果是THROW_IE，就是抛异常，如果是REINTERRUPT，就再自我中断一次，和获取独占锁里面原因一致
private void reportInterruptAfterWait(int interruptMode)
    throws InterruptedException {
    if (interruptMode == THROW_IE)
        throw new InterruptedException();
    else if (interruptMode == REINTERRUPT)
        selfInterrupt();
}
```






# `CountDownLatch`

基本使用在第二阶段中已讲

```java
package concurrent.phase2;

import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.stream.IntStream;

public class Client7 {

    private static final Random random = new Random(1000);

    public static void main(String[] args) {
        CountDownLatch latch = new CountDownLatch(5);
        System.out.println("第一阶段任务多线程处理");
        IntStream.rangeClosed(1, 5).forEach(i -> {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + " is working");
                try {
                    Thread.sleep(random.nextInt(100));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    latch.countDown();
                }
            }, String.valueOf(i)).start();
        });
        try {
            //注意这里不是wait，而是await
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("等待第一阶段多线程全部执行完成，第二阶段任务处理");
        System.out.println("finish");
    }
}
```

上面可以看到当计数器值达到0的时候会不再等待，还有另一种方式可以让其不再等待，就是调用`await`的线程（此处为主线程）中断可以，只是会抛出一个异常。

源码分析：

```java
package java.util.concurrent;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;

public class CountDownLatch {

    private static final class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 4982264981922014374L;

        Sync(int count) {
            setState(count);
        }

        int getCount() {
            return getState();
        }

        protected int tryAcquireShared(int acquires) {
            return (getState() == 0) ? 1 : -1;
        }

        protected boolean tryReleaseShared(int releases) {
            // 这里尝试去设置锁状态，成功后才真正由AQS去执行状态减一操作
            for (;;) {
                int c = getState();
                if (c == 0)
                    return false;
                int nextc = c-1;
                if (compareAndSetState(c, nextc))
                    return nextc == 0;
            }
        }
    }

    private final Sync sync;

    public boolean await(long timeout, TimeUnit unit)
        throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }

    /**
     * Decrements the count of the latch, releasing all waiting threads if
     * the count reaches zero.
     *
     * <p>If the current count is greater than zero then it is decremented.
     * If the new count is zero then all waiting threads are re-enabled for
     * thread scheduling purposes.
     *
     * <p>If the current count equals zero then nothing happens.
     */
    public void countDown() {
        sync.releaseShared(1);
    }
}
```

这里主要注意到是`Sync.tryReleaseShared`，这里是实现了`AQS`中的方法，这里传入值为1，每次释放锁的时候减一，这是使用了`AQS`中的共享锁机制。

下面看一个例子，比如有一个需要更新表字段的操作，这里我们需要更新表的`recordCount`和`clomnSchema`，有目标值和原始值，同时每更新完一个字段会给出一个事件对象来进行通知

```java
package concurrent.phase3;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo05 {

    public static void main(String[] args) {
        Event[] events = new Event[]{new Event(1), new Event(2)};
        ExecutorService pool = Executors.newFixedThreadPool(5);
        for (Event event : events) {
            List<Table> tables = capture(event);
            for (Table table : tables) {
                TrustSourceColumn trustSourceColumn = new TrustSourceColumn(table);
                TrustSourceRecordCount trustSourceRecordCount = new TrustSourceRecordCount(table);
                pool.submit(trustSourceColumn);
                pool.submit(trustSourceRecordCount);
            }
        }
    }

    static class Event {

        int id;

        public Event(int id) {
            this.id = id;
        }
    }

    static class Table {

        String tableName;
        long sourceRecordCount = 10;
        long targetCount;
        String sourceColumnSchema = "<table name = a><column name='coll' type='varchar2'/></table>";
        String targetColumnSchema = "";

        public Table(String tableName, long sourceRecordCount) {
            this.tableName = tableName;
            this.sourceRecordCount = sourceRecordCount;
        }
    }

    private static List<Table> capture(Event event) {
        List<Table> list = new ArrayList<>(10);
        for (int i = 0; i < 10; i++) {
            list.add(new Table("table-" + event.id + "-" + i, i * 1000));
        }
        return list;
    }

    static class TrustSourceColumn implements Runnable {

        private final Table table;

        public TrustSourceColumn(Table table) {
            this.table = table;
        }

        @Override
        public void run() {
            try {
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            table.targetColumnSchema = table.sourceColumnSchema;
            System.out.println("The table " + table.tableName + " target columns capture done and update.");
        }
    }

    static class TrustSourceRecordCount implements Runnable {

        private final Table table;

        public TrustSourceRecordCount(Table table) {
            this.table = table;
        }

        @Override
        public void run() {
            try {
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            table.targetCount = table.sourceRecordCount;
            System.out.println("The table " + table.tableName + " target record count capture done and update.");
        }
    }
}
```

这里每捕获到一个事件我们就去更新相关字段，但是这里会发现其实一个表的两个字段很显然是可以同时更新的，这样会提高效率。这里进行改造

```java
package concurrent.phase3;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo05 {

    public static void main(String[] args) {
        Event[] events = new Event[]{new Event(1), new Event(2)};
        ExecutorService pool = Executors.newFixedThreadPool(5);
        for (Event event : events) {
            List<Table> tables = capture(event);
            for (Table table : tables) {
                TaskBatch taskBatch = new TaskBatch(2);
                TrustSourceColumn trustSourceColumn = new TrustSourceColumn(table, taskBatch);
                TrustSourceRecordCount trustSourceRecordCount = new TrustSourceRecordCount(table, taskBatch);
                pool.submit(trustSourceColumn);
                pool.submit(trustSourceRecordCount);
            }
        }
    }

    interface Watcher {

        void done(Table table);
    }

    static class TaskBatch implements Watcher {

        private CountDownLatch latch;

        public TaskBatch(int size) {
            this.latch = new CountDownLatch(size);
        }

        @Override
        public void done(Table table) {
            latch.countDown();
            if (latch.getCount() == 0) {
                System.out.println("The table " + table.tableName + " finished the work,[" + table + "]");
            }
        }
    }

    static class Event {

        int id;

        public Event(int id) {
            this.id = id;
        }
    }

    static class Table {

        String tableName;
        long sourceRecordCount = 10;
        long targetCount;
        String sourceColumnSchema = "<table name = a><column name='coll' type='varchar2'/></table>";
        String targetColumnSchema = "";

        public Table(String tableName, long sourceRecordCount) {
            this.tableName = tableName;
            this.sourceRecordCount = sourceRecordCount;
        }

        @Override
        public String toString() {
            return "Table{" +
                "tableName='" + tableName + '\'' +
                ", sourceRecordCount=" + sourceRecordCount +
                ", targetCount=" + targetCount +
                ", sourceColumnSchema='" + sourceColumnSchema + '\'' +
                ", targetColumnSchema='" + targetColumnSchema + '\'' +
                '}';
        }
    }

    private static List<Table> capture(Event event) {
        List<Table> list = new ArrayList<>(10);
        for (int i = 0; i < 10; i++) {
            list.add(new Table("table-" + event.id + "-" + i, i * 1000));
        }
        return list;
    }

    static class TrustSourceColumn implements Runnable {

        private final Table table;
        private TaskBatch taskBatch;

        public TrustSourceColumn(Table table, TaskBatch taskBatch) {
            this.table = table;
            this.taskBatch = taskBatch;
        }

        @Override
        public void run() {
            try {
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            table.targetColumnSchema = table.sourceColumnSchema;
//            System.out.println("The table " + table.tableName + " target columns capture done and update.");
            taskBatch.done(table);
        }
    }

    static class TrustSourceRecordCount implements Runnable {

        private final Table table;
        private TaskBatch taskBatch;

        public TrustSourceRecordCount(Table table, TaskBatch taskBatch) {
            this.table = table;
            this.taskBatch = taskBatch;
        }

        @Override
        public void run() {
            try {
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            table.targetCount = table.sourceRecordCount;
//            System.out.println("The table " + table.tableName + " target record count capture done and update.");
            taskBatch.done(table);
        }
    }
}
```





# `CyclicBarrier`

`CyclicBarrier`有两个构造函数

```cpp
public CyclicBarrier(int parties)
public CyclicBarrier(int parties, Runnable barrierAction)
```

第一个参数，表示那个一起执行的线程个数。
第二个参数，表示线程都处于`barrier`时，一起执行之前，先执行的一个线程。



举个报旅行团旅行的例子。出发时，导游会在机场收了护照和签证，办理集体出境手续，所以，要等大家都到齐才能出发，出发前再把护照和签证发到大家手里。对应`CyclicBarrier`使用。每个人到达后进入`barrier`状态。都到达后，唤起大家一起出发去旅行。旅行出发前，导游还会有个发护照和签证的动作。



```java
package concurrent.phase3;

import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Demo06 {

    public static void main(String[] args) throws Exception {

        CyclicBarrier cyclicBarrier = new CyclicBarrier(3, new TourGuideTask());
        ExecutorService executor = Executors.newFixedThreadPool(3);
        //登哥最大牌，到的最晚
        executor.submit(new TravelTask(cyclicBarrier, "哈登", 5));
        executor.submit(new TravelTask(cyclicBarrier, "保罗", 3));
        executor.submit(new TravelTask(cyclicBarrier, "戈登", 1));
        executor.shutdown();
    }

    /**
     * 旅行线程
     */
    private static class TravelTask implements Runnable {

        private CyclicBarrier cyclicBarrier;
        private String name;
        private int arriveTime;//赶到的时间

        public TravelTask(CyclicBarrier cyclicBarrier, String name, int arriveTime) {
            this.cyclicBarrier = cyclicBarrier;
            this.name = name;
            this.arriveTime = arriveTime;
        }

        @Override
        public void run() {
            try {
                //模拟达到需要花的时间
                Thread.sleep(arriveTime * 1000);
                System.out.println(name + "到达集合点");
                cyclicBarrier.await();
                System.out.println(name + "开始旅行啦～～");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 导游线程，都到达目的地时，发放护照和签证
     */
    private static class TourGuideTask implements Runnable {

        @Override
        public void run() {
            System.out.println("****导游分发护照签证****");
            try {
                //模拟发护照签证需要2秒
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

这里要注意，和`CountDownLatch`不同的是，`CyclicBarrier`可以重置，在任务还没有到达同一个目标点的时候就可以使用`reset`方法重置，此时会抛出一个`BrokenBarrierException`异常。源码中主要关注`await`方法

```java
public int await() throws InterruptedException, BrokenBarrierException {
    try {
        return dowait(false, 0L);
    } catch (TimeoutException toe) {
        throw new Error(toe); // cannot happen
    }
}

private int dowait(boolean timed, long nanos)
    throws InterruptedException, BrokenBarrierException,
TimeoutException {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        final Generation g = generation;
        if (g.broken)
            throw new BrokenBarrierException();
        if (Thread.interrupted()) {
            breakBarrier();
            throw new InterruptedException();
        }

        int index = --count;
        //index为0表示所有线程都已到达栅栏，可以释放锁了
        if (index == 0) {  // tripped
            boolean ranAction = false;
            try {
                final Runnable command = barrierCommand;
                //这里就是我们设置的线程，如果有则要先运行
                if (command != null)
                    command.run();
                ranAction = true;
                //唤醒所有线程，释放锁
                nextGeneration();
                return 0;
            } finally {
                if (!ranAction)
                    breakBarrier();
            }
        }

        // 这里要注意：loop until tripped, broken, interrupted, or timed out
        for (;;) {
            try {
                if (!timed)
                    trip.await();
                else if (nanos > 0L)
                    nanos = trip.awaitNanos(nanos);
            } catch (InterruptedException ie) {
                if (g == generation && ! g.broken) {
                    breakBarrier();
                    throw ie;
                } else {
                    Thread.currentThread().interrupt();
                }
            }

            if (g.broken)
                throw new BrokenBarrierException();

            if (g != generation)
                return index;

            if (timed && nanos <= 0L) {
                //打开栅栏
                breakBarrier();
                throw new TimeoutException();
            }
        }
    } finally {
        lock.unlock();
    }
}
```

从这里可以看出，其实也是使用了一个计数，同时使用了可重入锁`Reentrant、Condition`来进行加锁。



# `Exchanger`

这个工具主要用来两个线程之间交换信息，基本用法如下

```java
package concurrent.phase3;

import java.util.concurrent.Exchanger;
import java.util.concurrent.TimeUnit;

public class Demo07 {

    public static void main(String[] args) {
        Exchanger<String> exchanger = new Exchanger<>();
        new Thread(() -> {
            try {
                System.out.println(Thread.currentThread().getName() + " start");
                String exchange = exchanger.exchange(" I come from " + Thread.currentThread().getName());
                System.out.println("Hi " + Thread.currentThread().getName() + exchange);
                System.out.println(Thread.currentThread().getName() + " end");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Thread1").start();

        new Thread(() -> {
            try {
                System.out.println(Thread.currentThread().getName() + " start");
                TimeUnit.SECONDS.sleep(10);
                String exchange = exchanger.exchange(" I come from " + Thread.currentThread().getName());
                System.out.println("Hi " + Thread.currentThread().getName() + exchange);
                System.out.println(Thread.currentThread().getName() + " end");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Thread2").start();
    }

}
```

这里要注意，这里交换的信息是同一个对象（可以通过将信息对象地址打印出来），此时就需要注意线程安全问题，同时此对象也可以多次使用，是同步进行数据交换的。允许原子性的交换两个（多个）对象，但同时只有一对才会成功。通过此对象还可以实现生产者消费者模式

```java
import java.util.concurrent.Exchanger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import org.apache.log4j.Logger;

public class ExchangerTest {
    protected static final Logger log = Logger.getLogger(ExchangerTest.class);
    private static volatile boolean isDone = false;

    static class ExchangerProducer implements Runnable {
        private Exchanger<Integer> exchanger;
        private static int data = 1;
        ExchangerProducer(Exchanger<Integer> exchanger) {
            this.exchanger = exchanger;
        }

        @Override
        public void run() {
            while (!Thread.interrupted() && !isDone) {
                for (int i = 1; i <= 3; i++) {
                    try {
                        TimeUnit.SECONDS.sleep(1);
                        data = i;
                        System.out.println("producer before: " + data);
                        data = exchanger.exchange(data);
                        System.out.println("producer after: " + data);
                    } catch (InterruptedException e) {
                        log.error(e, e);
                    }
                }
                isDone = true;
            }
        }
    }

    static class ExchangerConsumer implements Runnable {
        private Exchanger<Integer> exchanger;
        private static int data = 0;
        ExchangerConsumer(Exchanger<Integer> exchanger) {
            this.exchanger = exchanger;
        }

        @Override
        public void run() {
            while (!Thread.interrupted() && !isDone) {
                data = 0;
                System.out.println("consumer before : " + data);
                try {
                    TimeUnit.SECONDS.sleep(1);
                    data = exchanger.exchange(data);
                } catch (InterruptedException e) {
                    log.error(e, e);
                }
                System.out.println("consumer after : " + data);
            }
        }
    }

    /**
     * @param args
     */
    public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool();
        Exchanger<Integer> exchanger = new Exchanger<Integer>();
        ExchangerProducer producer = new ExchangerProducer(exchanger);
        ExchangerConsumer consumer = new ExchangerConsumer(exchanger);
        exec.execute(producer);
        exec.execute(consumer);
        exec.shutdown();
        try {
            exec.awaitTermination(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error(e, e);
        }
    }
}
```

```java
consumer before : 0
producer before: 1
consumer after : 1
producer after: 0
    
consumer before : 0
producer before: 2
producer after: 0
consumer after : 2
    
consumer before : 0
producer before: 3
producer after: 0
consumer after : 3
```



这要数据结构是

```java
private final Participant participant;
private volatile Node[] arena;
private volatile Node slot;

@sun.misc.Contended static final class Node {
    int index;              // arena的下标；
    int bound;              // 上一次记录的Exchanger.bound；
    int collides;           // 在当前bound下CAS失败的次数；
    int hash;               // 伪随机数，用于自旋；
    Object item;            // 这个线程的当前项，也就是需要交换的数据；
    volatile Object match;  // 做releasing操作的线程传递的项；
    volatile Thread parked; // 挂起时设置线程值，其他情况下为null；
}

/** The corresponding thread local class */
static final class Participant extends ThreadLocal<Node> {
    public Node initialValue() { return new Node(); }
}
```

这里`Contented`注解是用于避免伪共享的，缓存系统中是以缓存行（`cache line`）为单位存储的。缓存行是2的整数幂个连续字节，一般为`32-256`个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。参考：`https://www.jianshu.com/p/c3c108c3dcfd`。

`participant`的作用是为每个线程保留唯一的一个`Node`节点。

`slot`为单个槽，`arena`为数组槽。他们都是`Node`类型。在这里可能会感觉到疑惑，`slot`作为`Exchanger`交换数据的场景，应该只需要一个就可以了啊？为何还多了一个`Participant` 和数组类型的`arena`呢？一个`slot`交换场所原则上来说应该是可以的，但实际情况却不是如此，多个参与者使用同一个交换场所时，会存在严重伸缩性问题。既然单个交换场所存在问题，那么我们就安排多个，也就是数组`arena`。通过数组`arena`来安排不同的线程使用不同的`slot`来降低竞争问题，并且可以保证最终一定会成对交换数据。但是`Exchanger`不是一来就会生成`arena`数组来降低竞争，只有当产生竞争是才会生成`arena`数组。那么怎么将`Node`与当前线程绑定呢？`Participant` ，`Participant `的作用就是为每个线程保留唯一的一个`Node`节点，它继承`ThreadLocal`，同时在`Node`节点中记录在`arena`中的下标`index`。

在`Node`定义中有两个变量值得思考：`bound`以及`collides`。前面提到了数组`area`是为了避免竞争而产生的，如果系统不存在竞争问题，那么完全没有必要开辟一个高效的`arena`来徒增系统的复杂性。首先通过单个`slot`的`exchanger`来交换数据，当探测到竞争时将安排不同的位置的`slot`来保存线程`Node`，并且可以确保没有`slot`会在同一个缓存行上。如何来判断会有竞争呢？`CAS`替换`slot`失败，如果失败，则通过记录冲突次数来扩展`arena`的尺寸，我们在记录冲突的过程中会跟踪“`bound`”的值，以及在`bound`的值被改变时会重新计算冲突次数。

这里通过将`Node`存入`ThreadLocal`来进行数据交换

```java
public V exchange(V x) throws InterruptedException {
    Object v;
    Object item = (x == null) ? NULL_ITEM : x; // translate null args
    if ((arena != null ||
         (v = slotExchange(item, false, 0L)) == null) &&
        ((Thread.interrupted() || // disambiguates null return
          (v = arenaExchange(item, false, 0L)) == null)))
        throw new InterruptedException();
    return (v == NULL_ITEM) ? null : (V)v;
}
```

此方法传入的对象是要像另外一个线程交换的数据，而返回值是其他线程传过来的。这里有几种情况下直接抛出异常，若`arena`为空、交换过来的数据为空、线程被中断了。否则就返回交换后的数据。大致逻辑就是如果`slotExchange(Object item, boolean timed, long ns)`方法执行失败了就执行`arenaExchange(Object item, boolean timed, long ns)`方法，最后返回结果`V`。

```java
private final Object slotExchange(Object item, boolean timed, long ns) {
    // 获取当前线程的节点 p
    Node p = participant.get();
    // 当前线程
    Thread t = Thread.currentThread();
    // 线程中断，直接返回
    if (t.isInterrupted())
        return null;
    // 自旋
    for (Node q;;) {
        //slot != null
        if ((q = slot) != null) {
            // 尝试CAS替换，这里的SLOT是设置slot偏移量
            if (U.compareAndSwapObject(this, SLOT, q, null)) {
                Object v = q.item;      // 当前线程的项，上面交换成功了，此时这个q.item就是别人给过来的值
                q.match = item;         // 做releasing操作的线程传递的项，就是要给别人的值
                Thread w = q.parked;    // 挂起时设置线程值
                // 挂起线程不为null，线程释放
                if (w != null)
                    U.unpark(w);
                return v;
            }
            //如果失败了，表示有竞争，则创建arena
            //bound 则是上次Exchanger.bound
            if (NCPU > 1 && bound == 0 &&
                U.compareAndSwapInt(this, BOUND, 0, SEQ))
                arena = new Node[(FULL + 2) << ASHIFT];
        }
        //如果arena != null，直接返回null，进入arenaExchange逻辑处理
        else if (arena != null)
            return null;
        // slot和arena都为空，则尝试占领该slot
        else {
            p.item = item;
            if (U.compareAndSwapObject(this, SLOT, null, p))
                break;
            p.item = null;
        }
    }

    /*
     * 等待 release，因为可能另外一个线程还没到达，两个线程不一定是同步的
     * 进入spin+block模式，自旋+阻塞模式
     */
    int h = p.hash;
    long end = timed ? System.nanoTime() + ns : 0L;
    int spins = (NCPU > 1) ? SPINS : 1;
    Object v;
    while ((v = p.match) == null) {
        if (spins > 0) {
            h ^= h << 1; h ^= h >>> 3; h ^= h << 10;
            if (h == 0)
                h = SPINS | (int)t.getId();
            else if (h < 0 && (--spins & ((SPINS >>> 1) - 1)) == 0)
                Thread.yield();
        }
        //slot发生改变，也就是说当前线程发生改变
        else if (slot != p)
            spins = SPINS;
        else if (!t.isInterrupted() && arena == null &&
                 (!timed || (ns = end - System.nanoTime()) > 0L)) {
            U.putObject(t, BLOCKER, this);
            p.parked = t;
            if (slot == p)
                U.park(false, ns);
            p.parked = null;
            U.putObject(t, BLOCKER, null);
        }
        else if (U.compareAndSwapObject(this, SLOT, p, null)) {
            v = timed && ns <= 0L && !t.isInterrupted() ? TIMED_OUT : null;
            break;
        }
    }
    U.putOrderedObject(p, MATCH, null);
    p.item = null;
    p.hash = h;
    return v;
}
```

```java
private final Object arenaExchange(Object item, boolean timed, long ns) {
    Node[] a = arena;
    //取得当前线程所在节点
    Node p = participant.get();
    for (int i = p.index;;) {                      // access slot at i
        int b, m, c; long j;                       // j is raw array offset
        //找到对应位置线程节点
        Node q = (Node)U.getObjectVolatile(a, j = (i << ASHIFT) + ABASE);
        if (q != null && U.compareAndSwapObject(a, j, q, null)) {
            Object v = q.item;                     // release
            q.match = item;
            Thread w = q.parked;
            if (w != null)
                U.unpark(w);
            return v;
        }
        else if (i <= (m = (b = bound) & MMASK) && q == null) {
            p.item = item;                         // offer
            if (U.compareAndSwapObject(a, j, null, p)) {
                long end = (timed && m == 0) ? System.nanoTime() + ns : 0L;
                Thread t = Thread.currentThread(); // wait
                for (int h = p.hash, spins = SPINS;;) {
                    Object v = p.match;
                    if (v != null) {
                        U.putOrderedObject(p, MATCH, null);
                        p.item = null;             // clear for next use
                        p.hash = h;
                        return v;
                    }
                    else if (spins > 0) {
                        h ^= h << 1; h ^= h >>> 3; h ^= h << 10; // xorshift
                        if (h == 0)                // initialize hash
                            h = SPINS | (int)t.getId();
                        else if (h < 0 &&          // approx 50% true
                                 (--spins & ((SPINS >>> 1) - 1)) == 0)
                            Thread.yield();        // two yields per wait
                    }
                    else if (U.getObjectVolatile(a, j) != p)
                        spins = SPINS;       // releaser hasn't set match yet
                    else if (!t.isInterrupted() && m == 0 &&
                             (!timed ||
                              (ns = end - System.nanoTime()) > 0L)) {
                        U.putObject(t, BLOCKER, this); // emulate LockSupport
                        p.parked = t;              // minimize window
                        if (U.getObjectVolatile(a, j) == p)
                            U.park(false, ns);
                        p.parked = null;
                        U.putObject(t, BLOCKER, null);
                    }
                    else if (U.getObjectVolatile(a, j) == p &&
                             U.compareAndSwapObject(a, j, p, null)) {
                        if (m != 0)                // try to shrink
                            U.compareAndSwapInt(this, BOUND, b, b + SEQ - 1);
                        p.item = null;
                        p.hash = h;
                        i = p.index >>>= 1;        // descend
                        if (Thread.interrupted())
                            return null;
                        if (timed && m == 0 && ns <= 0L)
                            return TIMED_OUT;
                        break;                     // expired; restart
                    }
                }
            }
            else
                p.item = null;                     // clear offer
        }
        else {
            if (p.bound != b) {                    // stale; reset
                p.bound = b;
                p.collides = 0;
                i = (i != m || m == 0) ? m : m - 1;
            }
            else if ((c = p.collides) < m || m == FULL ||
                     !U.compareAndSwapInt(this, BOUND, b, b + SEQ + 1)) {
                p.collides = c + 1;
                i = (i == 0) ? m : i - 1;          // cyclically traverse
            }
            else
                i = m + 1;                         // grow
            p.index = i;
        }
    }
}
```

参考：`https://www.jianshu.com/p/c523826b2c94`。这个是真的难懂，而且对于两个线程的数据交换很好用，但是对于多个线程的交换则存在随机性，所以比较适合在两个线程交换的场景。



# `Semaphore`

其实就是一个信号量，每次获取之后减一，释放之后加一，当达到0的时候无法再次获取，下面看一个基本使用

```java
package concurrent.phase3;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class Demo09 {

    public static void main(String[] args) {
        final SemaphoreLock lock = new SemaphoreLock();
        for (int i = 0; i < 2; i++) {
            new Thread(() -> {
                try {
                    System.out.println(Thread.currentThread().getName() + " running");
                    lock.lock();
                    System.out.println(Thread.currentThread().getName() + " get the lock");
                    TimeUnit.SECONDS.sleep(10);
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
                System.out.println(Thread.currentThread().getName() + " release the lock");
            }).start();
        }
    }

    private static class SemaphoreLock {

        //只允许一个线程过去，修改为2则会发现两个线程可以同时获取到锁
        private final Semaphore semaphore = new Semaphore(1);

        private void lock() throws Exception {
            semaphore.acquire();
        }

        public void unlock() {
            semaphore.release();
        }
    }
}
```

当我们获取的时候使用`acquire`方法，若此时信号量值为0，那么会一直阻塞在这里。出去旅游的时候经常会遇到排队上洗手间的场景，这里参考网上例子：

```java
package concurrent.phase3;

import java.util.Arrays;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class Demo08 {

    public static void main(String[] args) {
        ResourceManage resourceManage = new ResourceManage();
        Thread[] threads = new Thread[100];
        for (int i = 0; i < 100; i++) {
            threads[i] = new Thread(new ResourceUser(resourceManage, i));
        }
        Arrays.asList(threads).forEach(Thread::start);
    }

    private static class ResourceUser implements Runnable {

        private ResourceManage resourceManage;
        private int userId;

        public ResourceUser(ResourceManage resourceManage, int userId) {
            this.resourceManage = resourceManage;
            this.userId = userId;
        }

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + ", 准备使用资源...");
            resourceManage.useResource(userId);
            System.out.println(Thread.currentThread().getName() + ", 使用资源完毕...");
        }
    }

    private static class ResourceManage {

        private boolean resources[];
        private final ReentrantLock lock;
        private final Semaphore semaphore;

        public ResourceManage() {
            this.resources = new boolean[10];
            Arrays.fill(this.resources, true);
            //公平锁，先来先进
            this.lock = new ReentrantLock(true);
            //控制10个共享资源使用，FIFO
            this.semaphore = new Semaphore(10, true);
        }

        public void useResource(int userId) {
            try {
                semaphore.acquire();
                //抢占资源
                int id = getResourceId();
                System.out.println(Thread.currentThread().getName() + ", userId:" + userId + " 正在使用资源，资源id: " + id);
                TimeUnit.SECONDS.sleep(10);
                resources[id] = true;
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                semaphore.release();
            }
        }

        private int getResourceId() {
            int id = -1;
            lock.lock();
            try {
                for (int i = 0; i < 10; i++) {
                    if (resources[i]) {
                        resources[i] = false;
                        id = i;
                        break;
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
            return id;
        }
    }
}
```

资源数量是有限的，其他人在坑满的情况下只能等待。

信号量也是在类中使用了`AQS`实现了公平锁和非公平锁（默认）两种锁。在构造方法中我们可以设置信号量的值和公平锁标志。



## `acquire`

```java
public void acquire() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}

public final void acquireSharedInterruptibly(int arg)
    throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) < 0)
        doAcquireSharedInterruptibly(arg);
}
```

这里其实就是获取一个信号量（信号量值减一），首先看`tryAcquireShared`方法

### 公平锁方式

```java
protected int tryAcquireShared(int acquires) {
    for (;;) {
        //这里参考AQS中说明，就是用来判断队列中是否有等待的线程了，如果有则直接入队
        if (hasQueuedPredecessors())
            return -1;
        //当前信号量的值
        int available = getState();
        // 减一
        int remaining = available - acquires;
        // 使用CAS方式设置值
        if (remaining < 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}
```

于是可以看到如果获取成功直接就返回了，若获取失败，则执行`doAcquireSharedInterruptibly`方法，在此方法中会阻塞（循环）获取

```java
private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    // 创建”当前线程“的Node节点，且Node中记录的锁是”共享锁“类型；并将该节点添加到CLH队列末尾。
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        for (;;) {
            // 如果上一节点是CLH队列的表头，则”尝试获取共享锁“。
            final Node p = node.predecessor();
            if (p == head) {
                //这里可以看到又开始获取锁了，验证了之前的调用就是一种快速失败的方式
                int r = tryAcquireShared(arg);
                //大于0表示获取到了
                if (r >= 0) {
                    //将当前线程设置为头节点，并传递唤醒后面线程
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            // 如果线程在等待过程中被中断过，则再次中断该线程(还原之前的中断状态)。
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        //发生异常或取消获取锁
        if (failed)
            cancelAcquire(node);
    }
}
```



### 非公平方式

```java
protected int tryAcquireShared(int acquires) {
    return nonfairTryAcquireShared(acquires);
}
final int nonfairTryAcquireShared(int acquires) {
    for (;;) {
        int available = getState();
        int remaining = available - acquires;
        if (remaining < 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}
```

非公平方式就是直接循环获取，谁快谁就能先取到。





# `release`

```java
public void release() {
    sync.releaseShared(1);
}
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
protected final boolean tryReleaseShared(int releases) {
    for (;;) {
        int current = getState();
        int next = current + releases;
        if (next < current) // overflow
            throw new Error("Maximum permit count exceeded");
        if (compareAndSetState(current, next))
            return true;
    }
}
private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                unparkSuccessor(h);
            }
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        if (h == head)                   // loop if head changed
            break;
    }
}
```

这里就是计数加一。然后将其队列后面的节点全部唤醒。



# `ReentrantLock`

参考：`https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html`

重入锁和之前的信号量锁有点类似，其实现也是使用了`AQS`，初始情况下默认为锁未被获取（值为0），获取到后值为一。基本用法如下

```java
package concurrent.phase3;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Demo10 {

    private static final Lock lock = new ReentrantLock();

    public static void main(String[] args) {
        for (int i = 0; i < 2; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread() + " start...");
                method1();
            }).start();
        }
    }

    public static void method1() {
        //一般时把lock方法调用放在try外面
        lock.lock();
        try {
            System.out.println(Thread.currentThread() + " start running");
            Thread.sleep(5000);
            System.out.println(Thread.currentThread() + " end");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

 ## `lock`

```java
public void lock() {
    sync.lock();
}
```



### 公平锁方式

```java
final void lock() {
    acquire(1);
}
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

这里首先尝试获取锁

```java
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    //0表示锁还没有被获取
    if (c == 0) {
        //若等待队列中无等待线程，且使用CAS将值设置成功，则表明获取锁成功
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            //将当前线程设置为独占
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    //锁已被获取，若获取锁的线程就是当前线程
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

若尝试获取锁失败了，然后开启自旋获取，这和之前信号量是类似的

```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

如果失败了，则需要将自己中断掉。



### 非公平锁方式

```java
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

非公平方式就是直接获取了。



## `unlock`

```java
public void unlock() {
    sync.release(1);
}
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        //头节点不为空，且状态不是初始状态，则唤醒队列中后面的线程
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    //当前线程不是占有锁的线程，异常返回
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    //释放锁
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```



## `newCondition`

这里的`condition`类似于`wait`和`notify`方法，因为之前需要在`synchronize`中使用（因为`wait`是释放锁，先决条件是要获取锁才能释放，而`notify`是将锁交给`wait`的线程，也是必须要自己有锁才能交出去），而我们使用重入锁的时候可以使用`condition`达到相同目的。

```java
package concurrent.phase3;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Demo11 {

    public static void main(String[] args) {
        Lock lock = new ReentrantLock();
        Condition condition = lock.newCondition();
        ReentrantLockThread1 t1 = new ReentrantLockThread1(lock, condition);
        ReentrantLockThread2 t2 = new ReentrantLockThread2(lock, condition);

        new Thread(t1).start();
        new Thread(t2).start();
    }

    private static class ReentrantLockThread1 implements Runnable {

        private Lock lock;
        private Condition condition;

        public ReentrantLockThread1(Lock lock, Condition condition) {
            this.lock = lock;
            this.condition = condition;
        }

        @Override
        public void run() {
            try {
                this.lock.lock();
                System.out.println("RUN THREAD 1-1");
                this.condition.await();
                System.out.println("RUN THREAD 1-2");
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                this.lock.unlock();
            }
        }
    }

    private static class ReentrantLockThread2 implements Runnable {

        private Lock lock;
        private Condition condition;

        public ReentrantLockThread2(Lock lock, Condition condition) {
            this.lock = lock;
            this.condition = condition;
        }

        @Override
        public void run() {
            try {
                this.lock.lock();
                System.out.println("RUN THREAD 2");
                this.condition.signal();
            } catch (Exception e) {
                throw new RuntimeException(e);
            } finally {
                this.lock.unlock();
            }
        }
    }
}
```

具体原理参考`AQS`。



## `lockInterruptibly`

1）如果当前线程未被中断，则获取锁。  

2）如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。  

3）如果当前线程已经保持此锁，则将保持计数加 1，并且该方法立即返回。  

4）如果锁被另一个线程保持，则出于线程调度目的，禁用当前线程，并且在发生以下两种情况之一以 前，该线程将一直处于休眠状态：      

* 锁由当前线程获得；或者
* 其他某个线程中断当前线程。  

5）如果当前线程获得该锁，则将锁保持计数设置为 1。    如果当前线程：        

* 在进入此方法时已经设置了该线程的中断状态；或者
* 在等待获取锁的同时被中断。     则抛出 `InterruptedException`，并且清除当前线程的已中断状态。   

6）在此实现中，因为此方法是一个显式中断点，所以要优先考虑响应中断，而不是响应锁的普通获取或 重入获取。 

此方法其实就是一个可以响应中断的获取锁方法，具体原理参考`AQS`



# `ReadWriteLock:ReentrantReadWriteLock`

`ReentrantReadWriteLock`是`Lock`的另一种实现方式，我们已经知道了`ReentrantLock`是一个排他锁，同一时间只允许一个线程访问，而`ReentrantReadWriteLock`允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时`ReentrantReadWriteLock`能够提供比排他锁更好的并发性和吞吐量。

`ReentrantReadWriteLock`支持以下功能：

1）支持公平和非公平的获取锁的方式；

2）支持可重入。读线程在获取了读锁后还可以获取读锁；写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；

3）还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；

4）读取锁和写入锁都支持锁获取期间的中断；

5）`Condition`支持。仅写入锁提供了一个 `Conditon `实现；读取锁不支持 `Conditon `，`readLock().newCondition() `会抛出 `UnsupportedOperationException`。 

一个基本的例子，从这个例子中可以看到如何进行读写锁切换

```java
class CachedData {
    Object data;
    volatile boolean cacheValid;    //缓存是否有效
    ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

    void processCachedData() {
        rwl.readLock().lock();    //获取读锁
        //如果缓存无效，更新cache;否则直接使用data
        if (!cacheValid) {
            // Must release read lock before acquiring write lock
            //获取写锁前须释放读锁
            rwl.readLock().unlock();
            rwl.writeLock().lock();
            // Recheck state because another thread might have acquired
            //   write lock and changed state before we did.
            if (!cacheValid) {
                data = ...
                cacheValid = true;
            }
            // Downgrade by acquiring read lock before releasing write lock
            //锁降级，在释放写锁前获取读锁
            rwl.readLock().lock();
            rwl.writeLock().unlock(); // Unlock write, still hold read
        }

        use(data);
        rwl.readLock().unlock();    //释放读锁
    }
}
```

```java
package concurrent.phase3;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class Demo12 {

    static Map<String, Object> datas = new HashMap<>();
    static ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    static Lock r = lock.readLock();
    static Lock w = lock.writeLock();

    public static void main(String[] args) {
        new Thread(() -> {
            for (int i = 0; i < 100; i++) {
                setData(i + "", i + "");
            }
        }).start();

        new Thread(() -> {
            for (int i = 0; i < 100; i++) {
                getData(i + "");
            }
        }).start();
    }

    public static void setData(String key, String value) {
        w.lock();
        try {
            datas.put(key, value);
            TimeUnit.SECONDS.sleep(1);
            System.out.println("写入的值是:" + key + "<->" + value);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            w.unlock();
        }
    }

    public static void getData(String key) {
        r.lock();
        try {
            TimeUnit.SECONDS.sleep(1);
            System.out.println("读取的值是：" + key + "<->" + datas.get(key));
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            r.unlock();
        }
    }

}
```

其实基本使用和之前的锁是一样的，只是进行了读写分离，我们要注意读锁和写锁的切换即可。下面分析下相关原理。

`ReentrantReadWriteLock `也是基于 `AQS` 实现的，它的自定义同步器（继承` AQS`）需要在同步状态（一个整型变量`state`）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。

```java
public class ReentrantReadWriteLock
        implements ReadWriteLock, java.io.Serializable {
    private static final long serialVersionUID = -6992448646407690164L;
    /** Inner class providing readlock */
    private final ReentrantReadWriteLock.ReadLock readerLock;
    /** Inner class providing writelock */
    private final ReentrantReadWriteLock.WriteLock writerLock;
    /** Performs all synchronization mechanics */
    final Sync sync;
}
```

这里也分为公平与非公平方式。



## 读锁

下面都通过公平锁进行说明

### 1、加锁

```java
public void lock() {
    sync.acquireShared(1);
}
//AQS中
public final void acquireShared(int arg) {
    //若尝试未成功（结果小于0），则进入自旋继续获取锁
    if (tryAcquireShared(arg) < 0)
        doAcquireShared(arg);
}
// 实现此方法
protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    int c = getState();
    // 取低16位写锁。存在写锁且当前线程不是获取写锁的线程，返回-1，获取读锁失败
    if (exclusiveCount(c) != 0 &&
        getExclusiveOwnerThread() != current)
        return -1;
    // 获取当前读锁的值
    int r = sharedCount(c);
    // 若判断不需要阻塞同时读锁也小于最大值的时候，进入读锁的获取中
    if (!readerShouldBlock() && r < MAX_COUNT &&
        //修改高16位的状态
        compareAndSetState(c, c + SHARED_UNIT)) {
        // 若读锁的值为0，即当前没有其他线程获取读锁
        if (r == 0) {
            //第一个读锁设置为当前线程
            firstReader = current;
            //读锁线程数量
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
            //若读锁线程就是当前线程，那么这里就是说再次获取读锁
            firstReaderHoldCount++;
        } else {
            //上一个读锁值
            HoldCounter rh = cachedHoldCounter;
            //若为空，或者当前线程不是这个缓存的线程
            if (rh == null || rh.tid != getThreadId(current))
                //则将当前占有读锁的线程设置为缓存线程
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    return fullTryAcquireShared(current);
}

// Sync.java
static final int SHARED_SHIFT   = 16; // 位数
static final int SHARED_UNIT    = (1 << SHARED_SHIFT);//这里是2的16次方
static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1; // 每个锁的最大重入次数，65535
static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;
//也就是 c >>> 16(无符号补0右移16位)，也就是获取读锁的状态
static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }
// c & 0x0000ffff，也就是将高16位全部抹去，获取到写锁的状态，不为0表示没有其他线程获取写锁
static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }

```

下面看尝试获取锁

```java
final boolean readerShouldBlock() {
    return hasQueuedPredecessors();
}
//AQS
public final boolean hasQueuedPredecessors() {
    // The correctness of this depends on head being initialized
    // before tail and on head.next being accurate if the current
    // thread is first in queue.
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

这里判断同步队列中是否有等待的线程，若存在则返回`true`，表明当前线程应该阻塞。

读锁获取的过程相对于独占锁而言会稍微复杂下，整个过程如下：

1. 因为存在锁降级情况，如果存在写锁且锁的持有者不是当前线程，则直接返回失败，否则继续。
2. 依据公平性原则，调用 `readerShouldBlock()` 方法来判断读锁是否不需要阻塞，读锁持有线程数小于最大值（`65535`），且 `CAS` 设置锁状态成



#### `HoldCounter`

在读锁获取锁和释放锁的过程中，我们一直都可以看到一个变量 `rh （HoldCounter ）`，该变量在读锁中扮演着非常重要的作用。

我们了解读锁的内在机制其实就是一个共享锁，为了更好理解` HoldCounter` ，我们暂且认为它不是一个锁的概念，而相当于一个计数器。一次共享锁的操作就相当于在该计数器的操作。获取共享锁，则该计数器 + 1，释放共享锁，该计数器 - 1。只有当线程获取共享锁后才能对共享锁进行释放、重入操作。所以 `HoldCounter` 的作用就是当前线程持有共享锁的数量，这个数量必须要与线程绑定在一起，否则操作其他线程锁就会抛出异常。

`HoldCounter` 是 `Sync` 的内部静态类。`ThreadLocalHoldCounter` 是 `Sync` 的内部静态类。

```java
static final class HoldCounter {
    int count = 0; // 计数器
    final long tid = getThreadId(Thread.currentThread()); // 线程编号
}
static final class ThreadLocalHoldCounter extends ThreadLocal<HoldCounter> {
    
    @Override
    public HoldCounter initialValue() {
        return new HoldCounter();
    }
    
}
```

通过 `ThreadLocalHoldCounter` 类，`HoldCounter` 就可以与线程进行绑定了。故而，`HoldCounter` 应该就是绑定线程上的一个计数器，而 `ThreadLocalHoldCounter `则是线程绑定的 `ThreadLocal`。

从上面我们可以看到 `ThreadLocal `将 `HoldCounter `绑定到当前线程上，同时 `HoldCounter `也持有线程编号，这样在释放锁的时候才能知道 `ReadWriteLock` 里面缓存的上一个读取线程（`cachedHoldCounter`）是否是当前线程。这样做的好处是可以减少`ThreadLocal.get() `方法的次调用数，因为这也是一个耗时操作。

需要说明的是这样 `HoldCounter` 绑定线程编号而不绑定线程对象的原因是，避免` HoldCounter `和 `ThreadLocal `互相绑定而导致 `GC` 难以释放它们（尽管 `GC` 能够智能的发现这种引用而回收它们，但是这需要一定的代价），所以其实这样做只是为了帮助 `GC` 快速回收对象而已。

这里解释下为何要引入` firstReader、firstReaderHoldCount` 变量。这是为了一个效率问题，`firstReader` 是不会放入到 `readHolds` 中的，如果读锁仅有一个的情况下，就会避免查找 `readHolds` 。


#### `fullTryAcquireShared`

```java
final int fullTryAcquireShared(Thread current) {
    HoldCounter rh = null;
    for (;;) {
        int c = getState();
        //若写锁不为0，并且不是当前线程占有的，直接返回-1
        if (exclusiveCount(c) != 0) {
            if (getExclusiveOwnerThread() != current)
                return -1;
            // else we hold the exclusive lock; blocking here
            // 是否需要阻塞等待
        } else if (readerShouldBlock()) {
            // Make sure we're not acquiring read lock reentrantly
            if (firstReader == current) {
                // assert firstReaderHoldCount > 0;
            } else {
                if (rh == null) {
                    rh = cachedHoldCounter;
                    //读锁不是当前线程，若其值为0，说明没有获取到读锁
                    if (rh == null || rh.tid != getThreadId(current)) {
                        //获取当前线程的HolderCounter
                        rh = readHolds.get();
                        if (rh.count == 0)
                            readHolds.remove();
                    }
                }
                //说明没得到锁
                if (rh.count == 0)
                    return -1;
            }
        }
        if (sharedCount(c) == MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        //修改高16位的状态
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            if (sharedCount(c) == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                firstReaderHoldCount++;
            } else {
                if (rh == null)
                    rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
                cachedHoldCounter = rh; // cache for release
            }
            return 1;
        }
    }
}
```

该方法会根据“是否需要阻塞等待”，“读取锁的共享计数是否超过限制”等等进行处理。如果不需要阻塞等待，并且锁的共享计数没有超过限制，则通过 `CAS` 尝试获取锁，并返回 1 。所以，**`fullTryAcquireShared(Thread)` 方法，是 `#tryAcquireShared(int unused)` 方法的自旋重试的逻辑。**











# `ForkJoin`









# `Phaser`









# `Condition`







