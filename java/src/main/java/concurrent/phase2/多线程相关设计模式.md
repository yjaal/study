# 多线程相关设计模式

## 单例设计模式

```java
package concurrent.phase2;

public class Singleton1 {
    
    private static final Singleton1 instance = new Singleton1();

    private Singleton1() {
        //empty
    }

    public static Singleton1 getInstance() {
        return instance;
    }
}
```

这是最简单的一种单例模式，在多线程情况下也是没问题的，但是就是这个类在加载的时候单例实例已经存在，可能我一时半会还不会用到，所以就想有一种懒加载的方式，当我用的时候再创建出来。

```java
package concurrent.phase2;

public class Singleton2 {

    private static Singleton2 instance;

    private Singleton2() {
        //empty
    }

    public static Singleton2 getInstance() {
        if (instance == null) {
            instance = new Singleton2();
        }
        return instance;
    }
}
```

这是最基本的懒加载方式，但是在多线程情况下会有问题，就是多个线程同时调用方法判断的时候拿到的实例都是空的，此时就会创建多个实例。那如果在**方法上加一个同步**可不可以呢？这是可以的，但是每次调用这个方法都需要去获取锁，这就变成了串行化了，会影响效率。于是我们使用双检查的方式

```java
package concurrent.phase2;

public class Singleton3 {

    private static Singleton3 instance;

    private Singleton3() {
        //empty
    }

    public static Singleton3 getInstance() {
        if (instance == null) {
            synchronized (Singleton3.class) {
                if (instance == null) {
                    instance = new Singleton3();
                }
            }
        }
        return instance;
    }
}
```

但是这里还是有一个问题，就是可能在实例化此对象的时候，其中引用了很多其他对象数据等等，需要一定时间才能做完，但是此时第一个线程已经返回了，第二个线程发现实例不为空就去用的时候，其实例引用的其他对象还没有真正的实例化完毕，此时就会导致空指针异常。这里涉及到重排序等优化。此时我们只需要使用`volatile`即可，此修饰表示不要给我做一些优化，实例返回了就表示实例化已经真正的完成了。

```java
package concurrent.phase2;

public class Singleton4 {

    private static volatile Singleton4 instance;

    private Singleton4() {
        //empty
    }

    public static Singleton4 getInstance() {
        if (instance == null) {
            synchronized (Singleton4.class) {
                if (instance == null) {
                    instance = new Singleton4();
                }
            }
        }
        return instance;
    }
}
```

比如

```java
package concurrent.phase2;

public class Singleton4 {

    private static volatile Singleton4 instance;
    
    private Object obj1;
    
    private Object obj2;

    private Singleton4() {
        this.obj1 = new Object();
        this.obj2 = new Object();
    }

    public static Singleton4 getInstance() {
        if (instance == null) {
            synchronized (Singleton4.class) {
                if (instance == null) {
                    instance = new Singleton4();
                }
            }
        }
        return instance;
    }
}
```

可以看到这里会出现对三个对象的new操作，`Singleton4、obj1、obj2`，如果不加`volatile`，那么这三个new操作可能会重排序，比如`Singleton4`先被`new`出来，其实在类加载的时候是先给一个链接，然后在内存中开辟位置初始化，当第一个线程被`new`出来后，可能`obj1`和`obj2`还未完成初始化，当时第二个线程发现单例对象已经不为空了，此时如果使用则会发生空指针异常，如果加了`volatile`，那么`obj1`和`obj2`的实例化就可以保证在`Singleton4`之前，这样就不会发生空指针了。



下面看一种更优雅的方式

```java
package concurrent.phase2;

public class Singleton5 {

    private Singleton5() {
        //empty
    }

    private static class InstanceHolder{
        private final static Singleton5 instance = new Singleton5();
    }

    public static Singleton5 getInstance() {
        return InstanceHolder.instance;
    }
}
```

这里也是一种懒加载的方式，但是我们知道类加载的顺序是：**加载->链接（验证+准备+解析）->初始化（使用前的准备）->使用->卸载**。`InstanceHolder`一开始相当于定义了一个类，在只是解析了一下，只有当真正调用的时候才会对其进行初始化。还有一种方式就是枚举，枚举类构造函数是私有的，同时其中定义的类都是`final`的。

```java
package concurrent.phase2;

public class Singleton6 {

    private Singleton6() {
        //empty
    }

    public static Singleton6 getInstance() {
        return Singleton.INTANCE.getInstance();
    }

    private enum Singleton {
        INTANCE;

        private final Singleton6 instance;

        Singleton() {
            instance = new Singleton6();
        }

        public Singleton6 getInstance() {
            return instance;
        }
    }
}
```



## WaitSet

这个`wait set` 集合就是当线程中调用`wait`方法后，会将当前线程加入到该集合中，等待此线程被唤醒重新抢锁执行。这里主要要注意的一点是下面的第四点，调用`wait`的时候会记住此刻程序执行到的地址，便于下次接着执行。

```java
package concurrent.phase2;

import java.util.stream.IntStream;

/**
 * 1、所有的对象都有一个wait set， 用来存放该对象 wait 方法之后进入 blocked 状态线程;
 * 2、线程被 notify 之后不一定会立即执行;
 * 3、线程被从 wait set 中唤醒的顺序不一定按照启动的顺序;
 * 4、当wait之后被唤醒时，虽然是需要重新获取锁，但是这里是接着上次被wait的地方执行，而不是重新来过，这样就死循环类
 */
public class WaitSet {

    private static final Object LOCK = new Object();

    public static void main(String[] args) {
        IntStream.rangeClosed(1, 10).forEach(i ->
            new Thread(String.valueOf(i)) {
                @Override
                public void run() {
                    synchronized (LOCK) {
                        try {
                            System.out.println(Thread.currentThread().getName() + " into wait ");
                            LOCK.wait();
                            System.out.println(Thread.currentThread().getName() + " out wait ");
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }.start());
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        IntStream.rangeClosed(1, 10).forEach(i -> {
                synchronized (LOCK) {
                    //一个一个唤醒
                    LOCK.notify();
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        );

    }
}
```



## volatile

先看一个简单的例子

```java
package concurrent.phase2;

public class Volatile1 {

    private volatile static int INIT_VAL = 0;

    private final static int MAX_LIMIT = 5;

    public static void main(String[] args) {
        new Thread(() -> {
            int localVal = INIT_VAL;
            while (localVal < MAX_LIMIT) {
                if (localVal != INIT_VAL) {
                    System.out.printf("reader: The value updated to [%d]\n", INIT_VAL);
                    localVal = INIT_VAL;
                }
            }
        }, "reader").start();

        new Thread(() -> {
            int localVal = INIT_VAL;
            while (INIT_VAL < MAX_LIMIT) {
                System.out.printf("writer: Updated the value  to [%d]\n", ++localVal);
                INIT_VAL = localVal;
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "writer").start();

    }
}
```

这里起了两个线程，第一个线程读取，第二个线程修改，可以发现我们通过`volatile`就可以让第一个线程感知到相关变量值的变化。如果我们将`volatile`去掉的话变量的修改被别的线程是无法感知的。同时我们发现线程1始终无法感知变量的变化。

`JAVA`内存模型一般是有一个主内存，然后比如这里有两个`CPU`，`CPU1`和`CPU2`，各自有自己的`Cache`， `Cache1`和`Cache2`。那难道线程1只是从主内存中读取了一次变量值，然后放在`Cache1`之后就一直使用`Cache1`中的变量值？下面实验下

```java
package concurrent.phase2;

public class Volatile2 {

    private static int INIT_VAL = 0;

    private final static int MAX_LIMIT = 50;

    public static void main(String[] args) {
        new Thread(() -> {
            while (INIT_VAL < MAX_LIMIT) {
                System.out.println("T1 -> " + (++INIT_VAL));
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "ADDER-1").start();

        new Thread(() -> {
            while (INIT_VAL < MAX_LIMIT) {
                System.out.println("T2 -> " + (++INIT_VAL));
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "ADDER-2").start();

    }
}
```

这里我们发现在运行的过程中线程1中途也还是会从主内存中取值的，并且将自己的值更新到了主内存，那前面一个例子中（去掉`volatile`）为什么线程1却始终感知不到变量的变化呢？这里是因为去掉`volatile`，不仅变量变化无法感知，同时在线程1中`JVM`做了优化，`JVM`发现线程1中只有读操作，于是认定这个变量不会发生变化，于是就只会从`Cache1`中获取值。而后面的例子中两个线程都有写操作。同时对于上面的例子就算我们将`INIT_VAL`使用`volatile`修饰，会发现两个线程读取到的值也会冲突，这是因为volatile并不能保证原子性。`volatile`的主要两个特性就是有序性和可见性。



### 内存模型

先看一个例子，就是程序在执行下面这段代码的时候发生的事情

```java
i = 1;
i++;
```

这里如果有两个线程或者两个`CPU`执行，发生的事情如下

```java
CPU1: main memory -> i=1 -> Cache1(i=1) -> Cache1(i+1) -> Cache1(i=2) -> main Memory(i=2)
CPU2: main memory -> i=1 -> Cache2(i=1) -> Cache2(i+1) -> Cache2(i=2) -> main Memory(i=2)
```

这里的意思就是大家从主内存中获取到的`i`的值都为1，虽然最后加了两次，但是最终值却还是为2，而不是3。解决此问题有几种方式：

1、给数据总线枷锁（总线：数据总线、地址总线、控制总线）

2、`CPU`高速缓存一致性协议（`MESI`），这可以保证`Cache`和主线程中同一个变量的值是相同的。其主要思想就是当`CPU`写入数据的时候，如果发现该变量被共享，会发出一个信号，通知其他线程缓存无效。然后其他线程重新从主内存中获取。



对于`JMM`（`java`内存模型）是为了屏蔽相关CPU不同导致的问题，一般来说定义的本地变量数据放在栈（线程共享）中，而每个线程都会有自己的本地内存（线程独享）。



### 三个概念

1、原子性

就是对某个变量的多个操作，要么都成功，要么都失败。

`JMM`：对基本数据类型的变量读写保证了原子性。这些操作不可能被中断。

```java
// 这里的操作是不可能被中断的
i = 10
cache(i=10) -> main memory(i=10)
    
a = 10;//满足原子性
b = a;//不满足（a = 10,  -> b = a）
c++;//不满足(c = 0 -> c + 1 -> c = 2)
```

这里对于`long`和`double`类型的，如果在`32`位机器上执行，由于高低位的原因，不能保证原子性。



2、可见性

某个线程对某个变量值的改变，另外线程能够感知

`JMM`：`volatile`



3、有序性

就是保证程序执行的顺序，如下一段代码

```java
boolean flag = false;
int i = 1;
flag = true;
i++;
```

单线程中，`CPU`只要保证最终结果一致即可，可能对`flag`值的修改在定义变量`i`之前（**重排序**），但是这不影响两个变量最终的值，因为这两个变量是无关的，但是这两个变量可能在其他线程是有关的，其他线程需要程序按照定义的顺序执行，此时就可以使用`volatile`来保证。

`JMM`：保证了一部分有序性（`happens-before`原则），这是使用**内存屏障**来实现的。

* 一个线程内对变量的操作是有序的

  ```java
  //这里第一步肯定是在第三步之前的
  int a;
  int b;
  a = 1;
  ```

* 解锁必须发生在加锁之后

* `volatile`修饰的变量，对于一个变量的写操作必须发生在读操作之前

* 传递规则：操作一个变量`A`先于`B`，`B`先于`C`，那么`A`肯定先于`C`被操作。

* 线程启动规则：线程的`start`方法先于`run`方法。

* 线程的中断规则：中断操作必须发生在捕获异常之前

* 对象的销毁规则：对象的初始化必须发生在`finalize`之前



`volatile`只保证有序性和可见性

1、保证重排序不会把后面的指令放到屏障前面，也不会把前面的指令发到屏障后面

2、强制对缓存的修改操作立即写入到主内存

3、如果是写操作，导致其他`CPU`中的缓存失效。



### 使用场景

1、状态量标记

2、屏障前后顺序一致



## 观察者（监听者）设计模式

当我们需要知道某个程序的执行步骤的时候有几种方式，一种就是不断的循环取值，但是这种方式可能我们在取值的过程中程序都已经执行到后面的步骤了，那另一种比较精准的方式就是程序执行到某一步骤的时候主动通知，这就是观察者模式。一般被观察者被称为（`Subject`主题），观察者被称为（`Observer`）

```java
// 主题
package concurrent.phase2;

import java.util.ArrayList;
import java.util.List;

public class Subject1 {

    //一个主题中维护了多个观察者
    private List<Observer1> observers = new ArrayList<>();

    private int state;

    public int getState() {
        return this.state;
    }

    public void setState(int state) {
        if (state == this.state) {
            return;
        }
        this.state = state;
        //状态变化时通知所有观察者
        notifyAllObservers();
    }

    public void attach(Observer1 observer) {
        observers.add(observer);
    }

    private void notifyAllObservers() {
        observers.forEach(Observer1::update);
    }
}
```



```java
// 观察者
package concurrent.phase2;

public abstract class Observer1 {

    protected Subject1 subject;

    public Observer1(Subject1 subject) {
        this.subject = subject;
        subject.attach(this);
    }

    public abstract void update();
}

--------
package concurrent.phase2;

public class BinaryObserver extends Observer1 {

    public BinaryObserver(Subject1 subject) {
        super(subject);
    }

    @Override
    public void update() {
        System.out.println("Binary Observer: " + Integer.toBinaryString(subject.getState()));
    }
}
--------
package concurrent.phase2;

public class OctalObserver extends Observer1 {

    public OctalObserver(Subject1 subject) {
        super(subject);
    }

    @Override
    public void update() {
        System.out.println("Octal Observer: " + Integer.toOctalString(subject.getState()));
    }
}
```



```java
package concurrent.phase2;

public class ObserverClient1 {

    public static void main(String[] args) {
        final Subject1 subject = new Subject1();
        BinaryObserver binaryObserver = new BinaryObserver(subject);
        OctalObserver octalObserver = new OctalObserver(subject);
        System.out.println("--------------");
        subject.setState(10);
    }
}
```

当然其实还可以更简单一些：

```java
//观察者
package concurrent.phase2;
public interface Observer1 {
    void update(int state);
}

//主题
package concurrent.phase2;

import java.util.ArrayList;
import java.util.List;

public class Subject1 {

    private List<Observer1> observers = new ArrayList<>();

    private int state;

    public int getState() {
        return this.state;
    }

    public void setState(int state) {
        if (state == this.state) {
            return;
        }
        this.state = state;
        notifyAllObservers();
    }

    public void attach(Observer1 observer) {
        observers.add(observer);
    }

    private void notifyAllObservers() {
        observers.forEach(s -> s.update(this.state));
    }
}

//应用
package concurrent.phase2;

public class ObserverClient1 {

    public static void main(String[] args) {
        final Subject1 subject = new Subject1();
        subject.attach(state -> System.out.println("Binary Observer: " + Integer.toBinaryString(state)));
        subject.attach(state -> System.out.println("Octal Observer: " + Integer.toOctalString(state)));
        subject.setState(10);

    }
}
```



下面看多线程中的应用

```java
//主题
package concurrent.phase2;

public abstract class Subject2 implements Runnable {

    //这里只是维护了一个观察者
    final protected Observer2 subject;

    public Subject2(final Observer2 subject) {
        this.subject = subject;
    }

    protected void notifyChange(final RunnableEvent event) {
        subject.onEvent(event);

    }

    public enum RunnableState {
        RUNNING, ERROR, DONE
    }

    public static class RunnableEvent {

        private final RunnableState state;
        private final Thread thread;
        private final Throwable cause;

        public RunnableEvent(RunnableState state, Thread thread, Throwable cause) {
            this.state = state;
            this.thread = thread;
            this.cause = cause;
        }

        public RunnableState getState() {
            return state;
        }

        public Thread getThread() {
            return thread;
        }

        public Throwable getCause() {
            return cause;
        }
    }
}
```



```java
//观察者接口
package concurrent.phase2;

import concurrent.phase2.Subject2.RunnableEvent;

public interface Observer2 {
    void onEvent(RunnableEvent event);
}
-------
//观察者
package concurrent.phase2;

import concurrent.phase2.Subject2.RunnableEvent;
import java.util.List;

public class ThreadLifeCycleObserver implements Observer2 {

    private final Object LOCK = new Object();

    /**
     * 这里启动几个线程，并监控其状态
     */
    public void concurrentQuery(List<String> ids) {
        if (ids == null || ids.isEmpty()) {
            return;
        }
        ids.forEach(id -> new Thread(new Subject2(this) {
            @Override
            public void run() {
                try {
                    notifyChange(new RunnableEvent(RunnableState.RUNNING, Thread.currentThread(), null));
                    System.out.println("query for the id " + id);
                    notifyChange(new RunnableEvent(RunnableState.DONE, Thread.currentThread(), null));
                } catch (Exception e) {
                    notifyChange(new RunnableEvent(RunnableState.ERROR, Thread.currentThread(), e));
                }
            }
        }, id).start());
    }

    @Override
    public void onEvent(RunnableEvent event) {
        synchronized (LOCK) {
            System.out.println("The runnable [ " + event.getThread().getName()
                + " ] data change and state is " + event.getState());
            if (event.getCause() != null) {
                System.out.println("The runnable [ " + event.getThread().getName()
                    + " ] process failed");
                event.getCause().printStackTrace();
            }
        }
    }
}
```



```java
package concurrent.phase2;

import java.util.Arrays;

public class ObserverClient2 {
    public static void main(String[] args) {
        ThreadLifeCycleObserver observer = new ThreadLifeCycleObserver();
        observer.concurrentQuery(Arrays.asList("1", "2"));
    }
}
```

这里就是只有一个观察者，此观察者启动了两个线程（分别对应其各自的主题），然后监控两个线程的生命周期。当线程状态发生变化的时候通知观察者。**基本写法就是在主题中维护观察者，然后当自己的状态发生变化时通知观察者。**同时还可以看到在上面的观察者中可以看到维护了一个锁，当多个线程或者说多个主题都来通知时需要先获取到锁才能进行状态变化通知。



## 单线程执行设计模式

多线程问题发生一般需要几个条件：有共享资源、存在临界值、多个线程发生竞争

```java
package concurrent.phase2;

public class Gate {

    private int counter = 0;

    //共享资源
    private String name = "no body";
    private String address = "no where";

    /**
     * 临界值
     */
    public void pass(String otherName, String otherAddress) {
        this.counter++;
        //竞争
        this.name = otherName;
        this.address = otherAddress;
        verify();
    }

    private void verify() {
        if (this.name.charAt(0) != this.address.charAt(0)) {
            System.out.println("------BROKEN----------" + toString());
        }
    }

    @Override
    public String toString() {
        return "Gate{" +
            "counter=" + counter +
            ", name='" + name + '\'' +
            ", address='" + address + '\'' +
            '}';
    }
}
```



```java
package concurrent.phase2;

public class UseGate extends Thread{

    private final Gate gate;

    private final String name;

    private final String address;

    public UseGate(String name, String address, Gate gate) {
        this.name = name;
        this.address = address;
        this.gate = gate;
    }

    @Override
    public void run() {
        System.out.println(name + " begin");
        while (true) {
            this.gate.pass(name, address);
        }
    }
}
```



```java
package concurrent.phase2;

public class Client1 {
    public static void main(String[] args) {
        Gate gate = new Gate();
        UseGate bj = new UseGate("Baobao", "Beijing", gate);
        UseGate sh = new UseGate("Shanglao", "Shanghai", gate);
        UseGate gz = new UseGate("Guanglao", "Guangzhou", gate);

        bj.start();
        sh.start();
        gz.start();
    }
}
```

上面这个例子就很好的展示了这种问题。只需要排除其中一个条件就可以排除多线程的问题，这里我们在`pass`和`toString`方法上加上`synchronize`同步即可，当然这其实相当于在`verify`上面也加了锁。但是这里有个问题就是，其实对于`verify`和`toString`方法来说，只是对共享资源的一个读操作，都加锁则会导致效率较低的问题。



## 读写锁

为了效率一般情况下对于多个线程的“读-读”操作是不需要加锁的，而对于“读-写”和“写-写”操作是需要加锁的。这个在读操作比较多的场景中是比较适合的。

```java
//读写锁
package concurrent.phase2;

public class ReadWriteLock {

    //当前正在读的线程数量
    private int readingReaders = 0;

    //当前等待读的线程数量
    private int waitingReaders = 0;

    //当前正在写的线程数量（>=0）
    private int writingWriters = 0;

    //当前等待写的线程数量
    private int waitingWriters = 0;

    //是否更偏向与写
    private boolean preferWriter = true;

    public ReadWriteLock() {
        this(true);
    }

    public ReadWriteLock(boolean preferWriter) {
        this.preferWriter = preferWriter;
    }

    public synchronized void readLock() throws InterruptedException {
        //刚获取到锁的时候肯定是一个等待状态
        this.waitingReaders++;
        try {
            //如果此时有正在写的线程，则等待
            while (writingWriters > 0 || (preferWriter && waitingWriters > 0)) {
                this.wait();
            }
            this.readingReaders++;
        } finally {
            //被中断或者被唤醒执行则等待读线程数量减少
            this.waitingReaders--;
        }
    }

    public synchronized void readUnlock() {
        this.readingReaders--;
        this.notifyAll();
    }

    public synchronized void writeLock() throws InterruptedException {
        this.waitingWriters++;
        try {
            //有读线程或者有写线程时都不能进行写
            while (this.readingReaders > 0 || this.writingWriters > 0) {
                this.wait();
            }
            this.writingWriters++;
        } finally {
            this.waitingWriters--;
        }
    }

    public synchronized void writeUnlock() {
        this.writingWriters--;
        this.notifyAll();
    }
}
```

```java
//共享数据
package concurrent.phase2;

import java.util.Arrays;

public class SharedData {

    private final char[] buffer;

    private final ReadWriteLock lock = new ReadWriteLock();

    public SharedData(int size) {
        this.buffer = new char[size];
        Arrays.fill(buffer, '*');
    }

    public char[] read() throws InterruptedException {
        try {
            lock.readLock();
            return doRead();
        } finally {
            lock.readUnlock();
        }
    }

    private char[] doRead() {
        //返回一个副本出去
        char[] newBuff = new char[buffer.length];
        System.arraycopy(buffer, 0, newBuff, 0, buffer.length);
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
        }
        return newBuff;
    }

    public void write(char c) throws InterruptedException {
        try {
            lock.writeLock();
            doWrite(c);
        } finally {
            lock.writeUnlock();
        }
    }

    private void doWrite(char c) {
        for (int i = 0; i < buffer.length; i++) {
            buffer[i] = c;
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
            }
        }
    }
}
```



```java
package concurrent.phase2;

import java.util.Random;

public class Client2 {

    public static void main(String[] args) {
        final SharedData data = new SharedData(10);
        new ReaderWork(data).start();
        new ReaderWork(data).start();
        new ReaderWork(data).start();
        new ReaderWork(data).start();
        new ReaderWork(data).start();

        new WriterWork(data, "fasdf").start();
        new WriterWork(data, "fasddsfaf").start();
    }


    public static class WriterWork extends Thread {

        private static final Random random = new Random(System.currentTimeMillis());
        private final SharedData data;
        private final String filler;

        private int index = 0;

        @Override
        public void run() {
            try {
                while (true) {
                    char c = nextChar();
                    data.write(c);
                    System.out.println(Thread.currentThread().getName() + " writes "+ c);
                    Thread.sleep(random.nextInt(1000));

                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        private char nextChar() {
            char c = filler.charAt(index);
            index++;
            if (index >= filler.length()) {
                index = 0;
            }
            return c;
        }

        public WriterWork(SharedData data, String filler) {
            this.data = data;
            this.filler = filler;
        }
    }

    public static class ReaderWork extends Thread {

        private static final Random random = new Random(System.currentTimeMillis());
        private final SharedData data;

        @Override
        public void run() {
            try {
                while (true) {
                    char[] readBuff = data.read();
                    System.out.println(Thread.currentThread().getName() + " reads "
                        + String.valueOf(readBuff));
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        public ReaderWork(SharedData data) {
            this.data = data;
        }
    }
}
```

这里可以看到读写锁的基本实现还是挺简单的，同时为了让写线程获取到锁，这里加了一个`preferWriter`来让锁更偏向于写操作，实际情况下可能是不需要的。



## 不可变对象

不可变对象比如`String`，它是线程安全的，当然也不是说可变对象就一定是线程不安全的。比如`servlet`就是线程不安全的。我们可以自己定义一个

```java
package concurrent.phase2;

public final class Person {

    private final String name;
    private final String address;

    public Person(String name, String address) {
        this.name = name;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public String getAddress() {
        return address;
    }

    @Override
    public String toString() {
        return "Person{" +
            "name='" + name + '\'' +
            ", address='" + address + '\'' +
            '}';
    }
}
```

这里类和相关类属性都使用了`final`，都是不可变的。从`String`源码中可以看到基本上方法都是不需要加锁的，而对于`StringBuffer`虽然是一个可变对象，但是却是线程安全的，因为几乎每个方法都加了锁。对于上面的类中如果我们定义一个集合对象，就算添加了锁也是线程不安全的，当然可以通过复制来保证线程安全，类似于`String`。



## Futrue

这里我们自己实现`Futrue`，当我们在做一个任务的时候，给这个任务一个票据，当任务完成后将结果给这个票据，我们拿着这个票据就可以获得到任务的结果了，这个票据就是`Future`。

```java
package concurrent.phase2;
/**
 * Future 相当于一个票据或者凭证，用于后面获取相关结果
 */
public interface MyFuture<T> {
    T get() throws InterruptedException;
}
----
package concurrent.phase2;
/**
 * 一个票据的具体实现
 */
public class AsynFuture<T> implements MyFuture<T> {
    private volatile boolean done = false;
    private T result;

    /**
     * 用于让外部调用通知结果
     */
    public void done(T result) {
        synchronized (this) {
            this.result = result;
            this.done = true;
            this.notifyAll();
        }
    }

    /**
     * 用于获取结果
     */
    @Override
    public T get() throws InterruptedException {
        synchronized (this) {
            while (!done) {
                this.wait();
            }
        }
        return result;
    }
}
```

一个任务接口，`call`方法实现就是用来做具体的事情，也就是主要的调用逻辑

```java
package concurrent.phase2;
/**
 * 有了票据，那怎样才能知道任务是否已经完成了呢？这就需要下面的Task了。
 * 只有任务自己才能知道自己是否已经完成了
 */
public interface MyFutureTask<T> {
    T call();
}
```

这里我们还需要一个连接器来连接票据和任务，同时这里又起了一个线程达到异步的效果。

```java
package concurrent.phase2;
public class FutureService {
    public <T> MyFuture<T> submit(final MyFutureTask<T> task) {
        AsynFuture<T> future = new AsynFuture<>();
        new Thread(() -> {
            //只有任务自己才能知道自己是否已经完成了
            T result = task.call();
            //任务完成后将结果通知给票据，后面我们从票据中就可以拿到结果了
            future.done(result);
        }).start();
        return future;
    }
}
```

```java
package concurrent.phase2;
public class Client3 {
    public static void main(String[] args) throws Exception {
        FutureService service = new FutureService();
        //提交一个任务
        MyFuture<String> future = service.submit(() -> {
            try {
                //do something
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "finish";
        });
        System.out.println("do other things");
        Thread.sleep(100);

        while (null == future.get()) {
            Thread.sleep(10);
        }
        System.out.println(future.get());
    }
}
```

从上面的测试可以看到，可能我们需要不断的去询问（`while`）任务是否已经完成，这样就有点麻烦。那能不能任务完成后通知我呢？

```java
//FutureService.java
public <T> MyFuture<T> submit(final MyFutureTask<T> task, Consumer<T> consumer) {
    AsynFuture<T> future = new AsynFuture<>();
    new Thread(() -> {
        //只有任务自己才能知道自己是否已经完成了
        T result = task.call();
        //任务完成后将结果通知给票据，后面我们从票据中就可以拿到结果了
        future.done(result);
        consumer.accept(result);
    }).start();
    return future;
}
```

当然这里我们只是用了一个`Consumer`接口，也可以实现自己的逻辑，比如存入数据库等等

```java
package concurrent.phase2;
public class Client3 {
    public static void main(String[] args) throws Exception {
        FutureService service = new FutureService();
        //提交一个任务
        service.submit(() -> {
            try {
                //do something
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "finish";
        }, System.out::println);

        System.out.println("do other things");
        Thread.sleep(100);
        System.out.println("other things done");
    }
}
```



## 忙等待（挂起）设计模式

有这种场景，比如正在做某一件事情，但是此时有另外一件事来请求了，此时需要后来的这个事情先等待，比如让这个事情先到一个队列中等待。

```java
//一个等待队列
package concurrent.phase2;

import java.util.LinkedList;

public class ReqQueue {

    private final LinkedList<Request> queue = new LinkedList<>();

    public Request getRequest() {
        synchronized (queue) {
            while (queue.size() <= 0) {
                try {
                    queue.wait();
                } catch (InterruptedException e) {
                    return null;
                }
            }
            return queue.removeFirst();
        }
    }

    public void putRequest(Request request) {
        synchronized (queue) {
            queue.addLast(request);
            queue.notifyAll();
        }
    }
}
```

```java
//请求
package concurrent.phase2;

public class Request {

    private final String value;

    public Request(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }
}
```

```java
//一个客户端和一个服务端，客户端一直发送请求，服务端一直接受请求，假设服务端处理速度慢于客户端发送速度
package concurrent.phase2;

public class Server4 extends Thread {

    private final ReqQueue queue;
    private volatile boolean flag = true;

    public Server4(ReqQueue queue) {
        this.queue = queue;
    }

    public void close() {
        this.flag = false;
        this.interrupt();
    }

    @Override
    public void run() {
        while (flag) {
            Request request = queue.getRequest();
            if (null == request) {
                System.out.println("Received the empty request.");
                continue;
            }
            System.out.println("Server-> " + request.getValue());
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                break;
            }
        }
    }
}
-------
package concurrent.phase2;

public class Client4 extends Thread {

    private final ReqQueue queue;
    private final String sendValue;

    public Client4(ReqQueue queue, String sendValue) {
        this.queue = queue;
        this.sendValue = sendValue;
    }

    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("Client-> request " + sendValue);
            queue.putRequest(new Request(sendValue));
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        final ReqQueue queue = new ReqQueue();
        new Client4(queue, "Alex").start();
        Server4 server = new Server4(queue);
        server.start();
        server.join();
        server.close();
    }
}
```

这里我们可以看到客户端运行完之后服务端还在运行。其实这个有点像生产者消费者模式，相关资源可以放在队列中。而这里的队列我们可以做成一个阻塞队列。



## ThreadLocal

基本使用

```java
package concurrent.phase2;
public class MyThreadLocal {

    private static ThreadLocal threadLocal = new ThreadLocal();

    public static void main(String[] args) throws InterruptedException {
        threadLocal.set("Alex");
        threadLocal.set("Jack");
        Thread.sleep(100);
        System.out.println(threadLocal.get());
    }
}
//这里会将前面一个值覆盖掉
```



```java
package concurrent.phase2;

public class MyThreadLocal {

    private final static ThreadLocal<String> threadLocal = new ThreadLocal();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            threadLocal.set("Thread-T1: ");
            try {
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().getName() + " " + threadLocal.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread t2 = new Thread(() -> {
            threadLocal.set("Thread-T2: ");
            try {
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().getName() + " " + threadLocal.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println("------------");
        System.out.println(Thread.currentThread().getName() + " " + threadLocal.get());
    }
}
```

这里可以发现输出的都是自己线程的变量值。对于早期版本的`ThreadLocal`，我们可以自己实现一个基本的进行测试

```java
package concurrent.phase2;

import java.util.HashMap;
import java.util.Map;

public class MyThreadLocal<T> {

    //以当前线程作为key
    private final Map<Thread, T> storage = new HashMap<>();

    public void set(T t) {
        synchronized (this) {
            storage.put(Thread.currentThread(), t);
        }
    }

    public T get() {
        synchronized (this) {
            T value = storage.get(Thread.currentThread());
            if (null == value) {
                return initValue();
            }
            return value;
        }
    }

    private T initValue() {
        return null;
    }
}
```

### 使用`ThreadLocal`来管理上下文

有时候一个线程执行需要很多步骤，中途需要缓存多个变量，此时我们可以使用一个`context`上下文来保存。

这里模拟两个阶段，一个是查数据库，一个是通过网络查询

```java
package concurrent.phase2;
public class DBQueryAction {

    public void excute(Context context) {
        try {
            Thread.sleep(1000);
            String name = Thread.currentThread().getName() + "-Alex";
            context.setName(name);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
-------
package concurrent.phase2;
public class HttpQueryAction {

    public void excute(Context context) {
        String name = context.getName();
        String cardId = getCardId(name);
        context.setCardId(cardId);
    }

    private String getCardId(String name) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return Thread.currentThread().getName() + "-134313253";
    }
}
```

然后有一个总的业务类

```java
package concurrent.phase2;
/**
 * 这里定义一个任务，这个任务实际业务逻辑由QueryAction来完成
 */
public class ExecutionTask implements Runnable {

    private DBQueryAction dbQueryAction = new DBQueryAction();
    private HttpQueryAction httpQueryAction = new HttpQueryAction();

    @Override
    public void run() {
        final Context context = new Context();
        dbQueryAction.excute(context);
        System.out.println("DBQueryAction success");
        httpQueryAction.excute(context);
        System.out.println("httpQueryAction success");
        System.out.println("The username is: " + context.getName()
            + " and card id is:" + context.getCardId());
    }
}
```

上下文类

```java
package concurrent.phase2;
public class Context {

    private String name;
    private String cardId;

    public void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public String getCardId() {
        return cardId;
    }
    public void setCardId(String cardId) {
        this.cardId = cardId;
    }
}
```



```java
package concurrent.phase2;
import java.util.stream.IntStream;

public class Client5 {

    public static void main(String[] args) {
        IntStream.range(1, 5).forEach(i -> new Thread(new ExecutionTask()).start());
    }
}
```

那这里可以很明显发现一个问题，就是上下文必须要从头传到尾，耦合度较高。此时可以使用`ThreadLocal`优化。

```java
package concurrent.phase2;
public final class ActionContext {

    private static final ThreadLocal<Context> threadLocal = ThreadLocal.withInitial(Context::new);

    //单例
    private static class ContextHolder{
        private final static ActionContext actionContext = new ActionContext();
    }

    public static ActionContext getActionContext() {
        return ContextHolder.actionContext;
    }

    public Context getContext() {
        return threadLocal.get();
    }
}
```

使用此对象来保存上下文信息

```java
package concurrent.phase2;
public class DBQueryAction {

    public void excute() {
        try {
            Context context = ActionContext.getActionContext().getContext();
            Thread.sleep(1000);
            String name = Thread.currentThread().getName() + "-Alex";
            context.setName(name);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

---
package concurrent.phase2;
public class HttpQueryAction {

    public void excute() {
        Context context = ActionContext.getActionContext().getContext();
        String name = context.getName();
        String cardId = getCardId(name);
        context.setCardId(cardId);
    }

    private String getCardId(String name) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return Thread.currentThread().getName() + "-134313253";
    }
}
```

这里可以看到我们是直接取的，不需要传入上下文对象。

```java
package concurrent.phase2;
/**
 * 这里定义一个任务，这个任务实际业务逻辑由QueryAction来完成
 */
public class ExecutionTask implements Runnable {

    private DBQueryAction dbQueryAction = new DBQueryAction();
    private HttpQueryAction httpQueryAction = new HttpQueryAction();

    @Override
    public void run() {
        final Context context = ActionContext.getActionContext().getContext();
        dbQueryAction.excute();
        System.out.println("DBQueryAction success");
        httpQueryAction.excute();
        System.out.println("httpQueryAction success");
        System.out.println("The username is: " + context.getName()
            + " and card id is:" + context.getCardId());
    }
}
```

**这里要注意：如果是使用线程池，在线程执行的时候需要先将上下文对象中的内容清楚，因为可能是线程之前运行留下的。**



## Balking（放弃）设计模式

比如去饭店之后看到一个距离很远的服务生招手，然后他准备过来的时候发现另外一个离我们很近的服务生，然后他就不过来了，让这个距离较近的服务生为我们服务，类似于一种委托的性质。还有就是一个任务的几个步骤，其中有一个步骤比较繁琐，之前讲有几种方式，一种是使用Future模式，另一种是使用挂起的方式，但是这两种方式都使用了线程间通信实现。

这是一种小技巧：

```java
package concurrent.phase2;
/**
 * 比如一个文件需要保存
 */
public class BalkingData {

    private final String fileName;

    private String content;

    private boolean changed;

    public BalkingData(String fileName, String content) {
        this.fileName = fileName;
        this.content = content;
        this.changed = true;
    }

    /**
     * 当收到新的内容时就将changed置为true，表示需要保存，注意此方法需要和
     * save方法成对出现，不然前面的内容会被覆盖掉
     */
    public synchronized void change(String newContent) {
        this.content = newContent;
        this.changed = true;
    }

    /**
     * 这里就相当于查看，如果文件没有收到新内容就直接返回了
     */
    public synchronized void save() {
        if (!changed) {
            return;
        }
        doSave();
        this.changed = false;
    }

    private void doSave() {
        System.out.println(Thread.currentThread().getName()
            + " content[" + content + "] has been saved");
    }
}
```



## 生产者消费者模式

```java
//共享数据
package concurrent.phase2;

import java.util.LinkedList;

public class ProducerData {

    private final LinkedList<String> data;

    private final int limit;

    private final static int MAX = 100;

    public ProducerData() {
        this(MAX);
    }

    public ProducerData(int limit) {
        this.data = new LinkedList<>();
        this.limit = limit;
    }

    public void put(String content) {
        synchronized (data) {
            while (data.size() >= limit) {
                try {
                    data.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            data.addLast(content);
            data.notifyAll();
        }
    }

    public String take() {
        synchronized (data) {
            while (data.isEmpty()) {
                try {
                    data.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            String res = data.removeFirst();
            data.notifyAll();
            return res;
        }
    }

    public int getLimit() {
        return limit;
    }

    public int size() {
        //这里要加锁
        synchronized (data) {
            return data.size();
        }
    }
}
```

```java
package concurrent.phase2;
import java.util.Random;
import java.util.concurrent.atomic.AtomicInteger;

public class Producer extends Thread{

    private final ProducerData data;

    private int seq;

    private final static AtomicInteger count = new AtomicInteger(0);

    private final static Random random = new Random(1000);

    public Producer(ProducerData data, int seq) {
        super("P" + seq);
        this.data = data;
    }

    @Override
    public void run() {
        while (true) {
            try {
                String msg = Thread.currentThread().getName() + "->" + count.getAndIncrement();
                data.put(msg);
                System.out.println(Thread.currentThread().getName() + " -> Produce -> " + msg);
                Thread.sleep(random.nextInt(100));
            } catch (Exception e) {
                break;
            }
        }
    }
}
```



```java
package concurrent.phase2;

import java.util.Random;

public class Consumer extends Thread{

    private final ProducerData data;

    private int seq;

    private final static Random random = new Random(1000);

    public Consumer(ProducerData data, int seq) {
        super("C" + seq);
        this.data = data;
    }

    @Override
    public void run() {
        while (true) {
            System.out.println(Thread.currentThread().getName() + " -> consume -> " + data.take());
            try {
                Thread.sleep(random.nextInt(100));
            } catch (InterruptedException e) {
                break;
            }
        }
    }
}
```

```java
package concurrent.phase2;
public class Client6 {

    public static void main(String[] args) throws InterruptedException {
        final ProducerData data = new ProducerData();
        new Producer(data, 1).start();
        new Producer(data, 2).start();
        new Producer(data, 3).start();
        new Consumer(data, 1).start();
        new Consumer(data, 2).start();
    }
}
```



## CountDown模式

先看`JDK`自带的如何使用

```java
package concurrent.phase2;

import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.stream.IntStream;

public class Client7 {

    private static final Random random = new Random(1000);

    public static void main(String[] args) {
        CountDownLatch latch = new CountDownLatch(5);
        System.out.println("第一阶段任务多线程处理");
        IntStream.rangeClosed(1, 5).forEach(i -> {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + " is working");
                try {
                    Thread.sleep(random.nextInt(100));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    latch.countDown();
                }
            }, String.valueOf(i)).start();
        });
        try {
            //注意这里不是wait，而是await
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("等待第一阶段多线程全部执行完成，第二阶段任务处理");
        System.out.println("finish");
    }
}
```

我们可以自己实现一个简单的

```java
package concurrent.phase2;

public class MyCountDown {

    private final int total;

    private int count;

    public MyCountDown(int total) {
        this.total = total;
    }

    public void countDown() {
        synchronized (this) {
            this.count++;
            this.notifyAll();
        }
    }

    public void await() throws InterruptedException {
        synchronized (this) {
            while (this.count != total) {
                this.wait();
            }
        }
    }
}
```

相关源码原理后面再研究。



## Thread-Per-Message 模式

这个其实就是类似于`Servlet`，比如一个网络请求过来了，那么就会有一个`Servlet`线程为这个请求服务，也就是一个线程服务一个请求。这种模式比较简单

```java
package concurrent.phase2;
import java.util.stream.IntStream;

public class Client8 {

    public static void main(String[] args) {
        MessageHandler handler = new MessageHandler();
        IntStream.rangeClosed(0, 10).forEach(i -> handler.request(String.valueOf(i)));
        handler.shutdown();
    }
}
```



```java
package concurrent.phase2;
import java.util.Random;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MessageHandler {

    private final static Random random = new Random(1000);

    private final static Executor executor = Executors.newFixedThreadPool(5);

    public void request(String msg) {
        executor.execute(() -> {
            try {
                Thread.sleep(random.nextInt(100));
                System.out.println("The message[ " + msg + " ] will be handle by "
                    + Thread.currentThread().getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }

    public void shutdown() {
        ((ExecutorService)executor).shutdown();
    }
}
```

































