# 多线程相关设计模式

## 单例设计模式

```java
package concurrent.phase2;

public class Singleton1 {
    
    private static final Singleton1 instance = new Singleton1();

    private Singleton1() {
        //empty
    }

    public static Singleton1 getInstance() {
        return instance;
    }
}
```

这是最简单的一种单例模式，在多线程情况下也是没问题的，但是就是这个类在加载的时候单例实例已经存在，可能我一时半会还不会用到，所以就想有一种懒加载的方式，当我用的时候再创建出来。

```java
package concurrent.phase2;

public class Singleton2 {

    private static Singleton2 instance;

    private Singleton2() {
        //empty
    }

    public static Singleton2 getInstance() {
        if (instance == null) {
            instance = new Singleton2();
        }
        return instance;
    }
}
```

这是最基本的懒加载方式，但是在多线程情况下会有问题，就是多个线程同时调用方法判断的时候拿到的实例都是空的，此时就会创建多个实例。那如果在**方法上加一个同步**可不可以呢？这是可以的，但是每次调用这个方法都需要去获取锁，这就变成了串行化了，会影响效率。于是我们使用双检查的方式

```java
package concurrent.phase2;

public class Singleton3 {

    private static Singleton3 instance;

    private Singleton3() {
        //empty
    }

    public static Singleton3 getInstance() {
        if (instance == null) {
            synchronized (Singleton3.class) {
                if (instance == null) {
                    instance = new Singleton3();
                }
            }
        }
        return instance;
    }
}
```

但是这里还是有一个问题，就是可能在实例化此对象的时候，其中引用了很多其他对象数据等等，需要一定时间才能做完，但是此时第一个线程已经返回了，第二个线程发现实例不为空就去用的时候，其实例引用的其他对象还没有真正的实例化完毕，此时就会导致空指针异常。这里涉及到重排序等优化。此时我们只需要使用`volatile`即可，此修饰表示不要给我做一些优化，实例返回了就表示实例化已经真正的完成了。

```java
package concurrent.phase2;

public class Singleton4 {

    private static volatile Singleton4 instance;

    private Singleton4() {
        //empty
    }

    public static Singleton4 getInstance() {
        if (instance == null) {
            synchronized (Singleton4.class) {
                if (instance == null) {
                    instance = new Singleton4();
                }
            }
        }
        return instance;
    }
}
```

下面看一种更优雅的方式

```java
package concurrent.phase2;

public class Singleton5 {

    private Singleton5() {
        //empty
    }

    private static class InstanceHolder{
        private final static Singleton5 instance = new Singleton5();
    }

    public static Singleton5 getInstance() {
        return InstanceHolder.instance;
    }
}
```

这里也是一种懒加载的方式，但是我们知道类加载的顺序是：**加载->链接（验证+准备+解析）->初始化（使用前的准备）->使用->卸载**。`InstanceHolder`一开始相当于定义了一个类，在只是解析了一下，只有当真正调用的时候才会对其进行初始化。还有一种方式就是枚举，枚举类构造函数是私有的，同时其中定义的类都是`final`的。

```java
package concurrent.phase2;

public class Singleton6 {

    private Singleton6() {
        //empty
    }

    public static Singleton6 getInstance() {
        return Singleton.INTANCE.getInstance();
    }

    private enum Singleton {
        INTANCE;

        private final Singleton6 instance;

        Singleton() {
            instance = new Singleton6();
        }

        public Singleton6 getInstance() {
            return instance;
        }
    }
}
```



## WaitSet

这个`wait set` 集合就是当线程中调用`wait`方法后，会将当前线程加入到该集合中，等待此线程被唤醒重新抢锁执行。这里主要要注意的一点是下面的第四点，调用`wait`的时候会记住此刻程序执行到的地址，便于下次接着执行。

```java
package concurrent.phase2;

import java.util.stream.IntStream;

/**
 * 1、所有的对象都有一个wait set， 用来存放该对象 wait 方法之后进入 blocked 状态线程;
 * 2、线程被 notify 之后不一定会立即执行;
 * 3、线程被从 wait set 中唤醒的顺序不一定按照启动的顺序;
 * 4、当wait之后被唤醒时，虽然是需要重新获取锁，但是这里是接着上次被wait的地方执行，而不是重新来过，这样就死循环类
 */
public class WaitSet {

    private static final Object LOCK = new Object();

    public static void main(String[] args) {
        IntStream.rangeClosed(1, 10).forEach(i ->
            new Thread(String.valueOf(i)) {
                @Override
                public void run() {
                    synchronized (LOCK) {
                        try {
                            System.out.println(Thread.currentThread().getName() + " into wait ");
                            LOCK.wait();
                            System.out.println(Thread.currentThread().getName() + " out wait ");
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }.start());
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        IntStream.rangeClosed(1, 10).forEach(i -> {
                synchronized (LOCK) {
                    //一个一个唤醒
                    LOCK.notify();
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        );

    }
}
```



## volatile

先看一个简单的例子

```java
package concurrent.phase2;

public class Volatile1 {

    private volatile static int INIT_VAL = 0;

    private final static int MAX_LIMIT = 5;

    public static void main(String[] args) {
        new Thread(() -> {
            int localVal = INIT_VAL;
            while (localVal < MAX_LIMIT) {
                if (localVal != INIT_VAL) {
                    System.out.printf("reader: The value updated to [%d]\n", INIT_VAL);
                    localVal = INIT_VAL;
                }
            }
        }, "reader").start();

        new Thread(() -> {
            int localVal = INIT_VAL;
            while (INIT_VAL < MAX_LIMIT) {
                System.out.printf("writer: Updated the value  to [%d]\n", ++localVal);
                INIT_VAL = localVal;
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "writer").start();

    }
}
```

这里起了两个线程，第一个线程读取，第二个线程修改，可以发现我们通过`volatile`就可以让第一个线程感知到相关变量值的变化。如果我们将`volatile`去掉的话变量的修改被别的线程是无法感知的。同时我们发现线程1始终无法感知变量的变化。

`JAVA`内存模型一般是有一个主内存，然后比如这里有两个`CPU`，`CPU1`和`CPU2`，各自有自己的`Cache`， `Cache1`和`Cache2`。那难道线程1只是从主内存中读取了一次变量值，然后放在`Cache1`之后就一直使用`Cache1`中的变量值？下面实验下

```java
package concurrent.phase2;

public class Volatile2 {

    private static int INIT_VAL = 0;

    private final static int MAX_LIMIT = 50;

    public static void main(String[] args) {
        new Thread(() -> {
            while (INIT_VAL < MAX_LIMIT) {
                System.out.println("T1 -> " + (++INIT_VAL));
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "ADDER-1").start();

        new Thread(() -> {
            while (INIT_VAL < MAX_LIMIT) {
                System.out.println("T2 -> " + (++INIT_VAL));
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "ADDER-2").start();

    }
}
```

这里我们发现在运行的过程中线程1中途也还是会从主内存中取值的，并且将自己的值更新到了主内存，那前面一个例子中（去掉`volatile`）为什么线程1却始终感知不到变量的变化呢？这里是因为去掉`volatile`，不仅变量变化无法感知，同时在线程1中`JVM`做了优化，`JVM`发现线程1中只有读操作，于是认定这个变量不会发生变化，于是就只会从`Cache1`中获取值。而后面的例子中两个线程都有写操作。













