摘自：`https://www.kancloud.cn/kancloud/pack/70126`

# 题目
有N种物品和一个容量为`V`的背包，每种物品都有无限件可用。第`i`种物品的费用是`c[i]`，价值是`w[i]`。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

# 基本思路
这个问题非常类似于`01`背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令`f[i][v]`表示前i种物品恰放入一个容量为`v`的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：

```java
f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}
```



```java
/**
* 时间复杂度为O(num * cap * k), 空间复杂度为O(num * cap * k)
*
* @param num    物品的总个数
* @param cap    背包的总容量
* @param values 物品价值
* @param costs  物品占用（体积/重量）
* @return 可获得的最大价值
*/
ublic int solution(int num, int cap, int[] values, int[] costs) {
	int[][] worths = new int[num + 1][cap + 1];
	for (int i = 1; i < num + 1; i++) {
		for (int j = 1; j < cap + 1; j++) {
			for (int k = 1; k * costs[i] <= j; k++) {
                // 注意：下面不能用worths[i-1][j]
				worths[i][j] = Math.max(worths[i][j], worths[i - 1][j - k * costs[i]] + k * values[i]);
			}
		}
		System.out.println(Arrays.toString(worths[i]));
	}
	int maxRes = Integer.MIN_VALUE;
	for (int i = 1; i < num + 1; i++) {
		maxRes = Math.max(maxRes, worths[i][cap]);
	}
	return maxRes;
}
```

注意：这里为啥不能直接取`worths[num][cap]`是因为最优解可能并不包含后面的物品。

这跟01背包问题一样有`O(VN)`个状态需要求解，但求解每个状态的时间已经不是常数了，求解状态`f[i][v]`的时间是`O(v/c[i])`，总的复杂度可以认为是`O(V*Σ(V/c[i]))`，是比较大的。

将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。

# 一个简单有效的优化
完全背包问题有一个很简单有效的优化，是这样的：若两件物品`i、j`满足`c[i]=w[j]`，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。

这个优化可以简单的`O(N^2)`地实现，一般都可以承受。另外，针对背包问题而言，比较不错的一种方法是：首先将费用大于V的物品去掉，然后使用类似计数排序的做法，计算出费用相同的物品中价值最高的是哪个，可以`O(V+N)`地完成这个优化。这个不太重要的过程就不给出伪代码了，希望你能独立思考写出伪代码或程序。

# 转化为01背包问题求解
既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选`V/c[i]`件，于是可以把第i种物品转化为`V/c[i]`件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。

更高效的转化方法是：把第i种物品拆成费用为`c[i]*2^k`、价值为`w[i]*2^k`的若干件物品，其中k满足`c[i]*2^k<=V`。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个`2^k`件物品的和。这样把每种物品拆成`O(log V/c[i])`件物品，是一个很大的改进。

但我们有更优的`O(VN)`的算法。

# `O(VN)`的算法
这个算法使用一维数组，先看伪代码：

```java
for i=1..N
    for v=0..V
        f[v]=max{f[v],f[v-cost]+weight}
```

你会发现，这个伪代码与P01的伪代码只有`v`的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照`v=V..0`的逆序来循环。这是因为要保证第i次循环中的状态`f[i][v]`是由状态`f[i-1][v-c[i]]`递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果`f[i-1][v-c[i]]`。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果`f[i][v-c[i]]`，所以就可以并且必须采用`v=0..V`的顺序循环。这就是这个简单的程序为何成立的道理。

值得一提的是，上面的伪代码中两层for循环的次序可以颠倒。这个结论有可能会带来算法时间常数上的优化。

这个算法也可以以另外的思路得出。例如，将基本思路中求解`f[i][v-c[i]]`的状态转移方程显式地写出来，代入原方程中，会发现该方程可以等价地变形成这种形式：

```java
f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}
```

将这个方程用一维数组实现，便得到了上面的伪代码。最后抽象出处理一件完全背包类物品的过程伪代码：

```java
procedure CompletePack(cost,weight)
    for v=cost..V
        f[v]=max{f[v],f[v-c[i]]+w[i]}
```

```java
/**
 * 优化
 * 时间复杂度为O(num * cap), 空间复杂度为O(cap)
 *
 * @param num    物品的总个数
 * @param cap    背包的总容量
 * @param values 物品价值
 * @param costs  物品占用（体积/重量）
 * @return 可获得的最大价值
 */
public int solution1(int num, int cap, int[] values, int[] costs) {
	int[] worths = new int[cap + 1];
	for (int i = 1; i < num + 1; i++) {
		for (int j = costs[i]; j < cap + 1; j++) {
			worths[j] = Math.max(worths[j], worths[j - costs[i]] + values[i]);
		}
	}
	return worths[cap];
}
```



# 总结

完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。